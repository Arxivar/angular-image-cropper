(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("angular"));
	else if(typeof define === 'function' && define.amd)
		define(["angular"], factory);
	else if(typeof exports === 'object')
		exports["imageCropper"] = factory(require("angular"));
	else
		root["imageCropper"] = factory(root["angular"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

eval("var angular = __webpack_require__(1);\r\n\r\nvar ngModule = angular.module('imageCropper', []);\r\n\r\nvar Cropper = __webpack_require__(2);\r\n__webpack_require__(3)(angular, Cropper);\r\n\r\nmodule.exports = 'imageCropper';//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/OTU1MiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxuXHJcbnZhciBuZ01vZHVsZSA9IGFuZ3VsYXIubW9kdWxlKCdpbWFnZUNyb3BwZXInLCBbXSk7XHJcblxyXG52YXIgQ3JvcHBlciA9IHJlcXVpcmUoJy4vaW1hZ2VDcm9wcGVyJyk7XHJcbnJlcXVpcmUoJy4vaW1hZ2VDcm9wcGVyRGlyZWN0aXZlJykoYW5ndWxhciwgQ3JvcHBlcik7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9ICdpbWFnZUNyb3BwZXInO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_1__;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJhbmd1bGFyXCI/MTFkMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzFfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImFuZ3VsYXJcIlxuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n");

/***/ }),
/* 2 */
/***/ (function(module, exports) {

eval("module.exports = Cropper;\r\n\r\n/**\r\n * Cropper.\r\n * @param options\r\n * @returns {Cropper}\r\n * @constructor\r\n */\r\nfunction Cropper(options) {\r\n\r\n  if (!options.imageUrl) {\r\n    throw new Error('Cropper: No image url given.');\r\n  }\r\n\r\n  this.isReady = false;\r\n  this.originalUrl = options.imageUrl;\r\n\r\n  // Default options.\r\n  var defaults = {\r\n    checkCrossOrigin: false,\r\n    apiCallback: undefined,\r\n    cropCallback: undefined,\r\n    width: 400,\r\n    height: 300,\r\n    imageUrl: undefined,\r\n    target: undefined,\r\n    showControls: true,\r\n    fitOnInit: false,\r\n    centerOnInit: false,\r\n    zoomStep: 0.1,\r\n    actionLabels: {\r\n      rotateLeft: ' < ',\r\n      rotateRight: ' > ',\r\n      zoomIn: ' + ',\r\n      zoomOut: ' - ',\r\n      fit: '(fit)',\r\n      crop: '[crop]'\r\n    }\r\n  };\r\n\r\n  // Setup options.\r\n  this.options = this.extend(defaults, options);\r\n\r\n  // Setup gesture events.\r\n  this.gesture = {};\r\n  this.gesture.events = {\r\n    start: 'touchstart mousedown',\r\n    move: 'touchmove mousemove',\r\n    stop: 'touchend mouseup'\r\n  };\r\n\r\n  this.pointerPosition = undefined;\r\n\r\n  // Setup basic elements.\r\n  this.elements = {\r\n    target: options.target,\r\n    body: document.getElementsByTagName('body')[0]\r\n  };\r\n\r\n  this.buildDOM();\r\n  this.useHardwareAccelerate(this.elements.image);\r\n\r\n  // API Setup:\r\n  var api = {\r\n    crop: this.cropImage.bind(this),\r\n    fit: this.applyFit.bind(this),\r\n    rotate: this.applyRotation.bind(this),\r\n    zoomIn: this.applyZoomIn.bind(this),\r\n    zoomOut: this.applyZoomOut.bind(this),\r\n    remove: this.remove.bind(this)\r\n  };\r\n\r\n  /**\r\n   * Initialization of the Cropper (dimensions, event binding...).\r\n   */\r\n  this.events.on('ImageReady', this.initialize.bind(this));\r\n\r\n  /**\r\n   * Execute callback function when cropped.\r\n   */\r\n  if (this.options.cropCallback) {\r\n    this.events.on('Cropped', function(base64) {\r\n      this.options.cropCallback(base64);\r\n    }.bind(this));\r\n  }\r\n\r\n  /**\r\n   * Send API when image is ready if readyCallback is true.\r\n   */\r\n  if (this.options.apiCallback) {\r\n    this.events.on('ImageReady', function() {\r\n      this.options.apiCallback(api);\r\n    }.bind(this));\r\n  }\r\n}\r\n\r\nCropper.prototype.initialize = function() {\r\n  this.setDimensions();\r\n\r\n  if (this.imageHasToFit()) {\r\n    this.fitImage();\r\n    this.centerImage();\r\n  }\r\n  this.initializeGesture();\r\n\r\n  if (this.options.centerOnInit) {\r\n    this.centerImage();\r\n  }\r\n\r\n  if (this.options.showControls) {\r\n    this.bindControls();\r\n  }\r\n};\r\n\r\nCropper.prototype.bindControls = function() {\r\n  var self = this;\r\n  this.elements.controls.rotateLeft.addEventListener('click', function() {\r\n    self.applyRotation(-90);\r\n  });\r\n  this.elements.controls.rotateRight.addEventListener('click', function() {\r\n    self.applyRotation(90);\r\n  });\r\n  this.elements.controls.zoomIn.addEventListener('click', function() {\r\n    self.applyZoomIn(self.zoomInFactor);\r\n  });\r\n  this.elements.controls.zoomOut.addEventListener('click', function() {\r\n    self.applyZoomOut(self.zoomOutFactor);\r\n  });\r\n  this.elements.controls.fit.addEventListener('click', this.applyFit.bind(this));\r\n  this.elements.controls.crop.addEventListener('click', this.cropImage.bind(this));\r\n};\r\n\r\nCropper.prototype.applyRotation = function(degree) {\r\n  this.rotateImage(degree);\r\n};\r\n\r\nCropper.prototype.applyZoomIn = function(zoom) {\r\n  this.zoomImage(1 + parseFloat(zoom));\r\n};\r\nCropper.prototype.applyZoomOut = function(zoom) {\r\n  this.zoomImage(1 / ( 1 + parseFloat(zoom)));\r\n};\r\n\r\nCropper.prototype.applyFit = function() {\r\n  this.fitImage();\r\n  this.centerImage();\r\n};\r\n\r\nCropper.prototype.imageHasToFit = function() {\r\n  return this.elements.image.naturalWidth < this.options.width ||\r\n    this.elements.image.naturalHeight < this.options.height ||\r\n    this.width < 1 || this.height < 1 || // 1 means 100%.\r\n    this.options.fitOnInit;\r\n};\r\n\r\n/**\r\n * Build DOM element for the Cropper appended in the targeted element.\r\n */\r\nCropper.prototype.buildDOM = function() {\r\n  var _elements;\r\n  _elements = this.elements;\r\n\r\n  // Wrapper.\r\n  _elements.wrapper = document.createElement('div');\r\n  _elements.wrapper.className = 'imgCropper-wrapper';\r\n\r\n  // Container.\r\n  _elements.container = document.createElement('div');\r\n  _elements.container.className = 'imgCropper-container';\r\n\r\n  // Image.\r\n  _elements.image = document.createElement('img');\r\n  _elements.image.className = 'imgCropper-image';\r\n\r\n\r\n  // Target -> Wrapper -> Container -> Image\r\n  _elements.container.appendChild(_elements.image);\r\n  _elements.wrapper.appendChild(_elements.container);\r\n  _elements.target.appendChild(_elements.wrapper);\r\n\r\n  if (!this.options.showControls) {\r\n    return this.loadImage();\r\n  }\r\n\r\n  // Controls.\r\n  _elements.controls = {};\r\n  _elements.controls.wrapper = document.createElement('div');\r\n  _elements.controls.wrapper.className = 'imgCropper-controls';\r\n\r\n  _elements.controls.rotateLeft = this._buildControl(this.options.actionLabels.rotateLeft);\r\n  _elements.controls.rotateRight = this._buildControl(this.options.actionLabels.rotateRight);\r\n  _elements.controls.zoomIn = this._buildControl(this.options.actionLabels.zoomIn);\r\n  _elements.controls.zoomOut = this._buildControl(this.options.actionLabels.zoomOut);\r\n  _elements.controls.fit = this._buildControl(this.options.actionLabels.fit);\r\n\r\n  _elements.controls.crop = this._buildControl(this.options.actionLabels.crop);\r\n\r\n\t// Target -> Wrapper -> buttons\r\n\t//d.parisi non passando la relativa label è ora possibile nascondere un bottone\r\n\tif(this.options.actionLabels.rotateLeft){\r\n\t\t_elements.controls.wrapper.appendChild(_elements.controls.rotateLeft);\r\n\t}\r\n\tif(this.options.actionLabels.zoomOut){\r\n\t\t_elements.controls.wrapper.appendChild(_elements.controls.zoomOut);\r\n\t}\r\n\tif(this.options.actionLabels.fit){\r\n\t\t_elements.controls.wrapper.appendChild(_elements.controls.fit);\r\n\t}\r\n\tif(this.options.actionLabels.crop){\r\n\t\t_elements.controls.wrapper.appendChild(_elements.controls.crop);\r\n\t}\r\n\tif(this.options.actionLabels.zoomIn){\r\n\t\t_elements.controls.wrapper.appendChild(_elements.controls.zoomIn);\r\n\t}\r\n\tif(this.options.actionLabels.rotateRight){\r\n\t\t_elements.controls.wrapper.appendChild(_elements.controls.rotateRight);\r\n\t}\r\n\r\n\t_elements.target.appendChild(_elements.controls.wrapper);\r\n  this.loadImage();\r\n};\r\n\r\n/**\r\n * Build control element.\r\n * @param label\r\n * @returns {Element}\r\n */\r\nCropper.prototype._buildControl = function(label) {\r\n  var control = document.createElement('button');\r\n  control.setAttribute('type', 'button');\r\n  control.innerHTML = label;\r\n\r\n  return control;\r\n};\r\n\r\n/**\r\n * Remove all DOM element parts of the Cropper.\r\n */\r\nCropper.prototype.remove = function() {\r\n  var elements = this.elements;\r\n  elements.target.removeChild(elements.wrapper);\r\n  if (this.options.showControls) elements.target.removeChild(elements.controls.wrapper);\r\n};\r\n\r\nCropper.prototype.changeImage = function(newImageUrl) {\r\n  if (typeof newImageUrl === 'undefined' || newImageUrl === '') {\r\n    return;\r\n  }\r\n\r\n  this.originalUrl = newImageUrl;\r\n  this.loadImage();\r\n};\r\n\r\nCropper.prototype.loadImage = function() {\r\n  var self = this;\r\n  var xhr;\r\n\r\n  // XMLHttpRequest disallows to open a Data URL in some browsers like IE11 and Safari.\r\n  if (/^data\\:/.test(this.originalUrl)) {\r\n    this.originalBase64 = this.originalUrl;\r\n    return this.setupImageSRC();\r\n  }\r\n\r\n  xhr = new XMLHttpRequest();\r\n  xhr.onerror = xhr.onabort = function(response) {\r\n    self.originalBase64 = self.originalUrl;\r\n    self.setupImageSRC();\r\n  };\r\n\r\n  // Need to have proper sets of 'Access-Control-Allow-Origin' on the requested resource server.\r\n  xhr.onload = function() {\r\n    self.originalArrayBuffer = this.response;\r\n    self.originalBase64 = 'data:image/jpeg;base64,' + self.base64ArrayBuffer(this.response);\r\n    self.setupImageSRC();\r\n  };\r\n  xhr.open('get', this.originalUrl, true);\r\n  //xhr.setRequestHeader('Content-Type', 'image/jpg'); // TODO: Auto determine the image MIME's type.\r\n  xhr.responseType = 'arraybuffer';\r\n  xhr.send();\r\n};\r\n\r\n/**\r\n * Check crossOrigins and setup image src.\r\n */\r\nCropper.prototype.setupImageSRC = function() {\r\n  var _image = this.elements.image;\r\n\r\n  if (this.options.checkCrossOrigin && this.isCrossOrigin(this.originalUrl)) {\r\n    this.crossOrigin = _image.crossOrigin;\r\n\r\n    if (this.crossOrigin) {\r\n      this.crossOrigin = this.originalUrl;\r\n    } else {\r\n      this.crossOrigin = 'anonymous';\r\n\r\n      // Bust cache with a timestamp.\r\n      this.crossOriginUrl = this.addTimestamp(this.originalUrl);\r\n    }\r\n  }\r\n\r\n  if (this.crossOrigin) {\r\n    this.elements.image.crossOrigin = this.crossOrigin;\r\n  }\r\n\r\n  // Setup image src.\r\n  this.elements.image.src = this.crossOriginUrl || this.originalUrl; // Need to verify.\r\n  //this.elements.image.src = this.originalBase64; // Need to verify.\r\n\r\n  // Waiting the image as loaded to trigger event.\r\n  this.elements.image.onload = function() {\r\n    this.events.triggerHandler('ImageReady');\r\n  }.bind(this);\r\n};\r\n\r\n/**\r\n * Set dimensions.\r\n */\r\nCropper.prototype.setDimensions = function() {\r\n  this.zoomInFactor = 1 + parseFloat(this.options.zoomStep);\r\n  this.zoomOutFactor = 1 / this.zoomInFactor;\r\n\r\n  this.imageRatio = this.options.height / this.options.width;\r\n  this.width = this.elements.image.naturalWidth / this.options.width;\r\n  this.height = this.elements.image.naturalHeight / this.options.height;\r\n  this.left = 0;\r\n  this.top = 0;\r\n  this.angle = 0;\r\n  this.data = {\r\n    scale: 1,\r\n    degrees: 0,\r\n    x: 0,\r\n    y: 0,\r\n    w: this.options.width,\r\n    h: this.options.height\r\n  };\r\n\r\n  // Container.\r\n  this.elements.container.style.width = this.width * 100 + '%';\r\n  this.elements.container.style.height = this.height * 100 + '%';\r\n  this.elements.container.style.top = 0;\r\n  this.elements.container.style.left = 0;\r\n\r\n  // Wrapper.\r\n  this.elements.wrapper.style.height = 'auto';\r\n  this.elements.wrapper.style.width = '100%';\r\n  this.elements.wrapper.style.paddingTop = (this.imageRatio * 100) + '%';\r\n\r\n  this.isReady = true;\r\n};\r\n\r\n/**\r\n * Image should be already loaded.\r\n */\r\nCropper.prototype.initializeGesture = function() {\r\n  var self = this;\r\n  this.addEventListeners(this.elements.image, this.gesture.events.start, function(event) {\r\n    if (self.isReady && self.isValidEvent(event)) {\r\n      event.preventDefault();\r\n      event.stopImmediatePropagation();\r\n      self.pointerPosition = self.getPointerPosition(event);\r\n      bind();\r\n    }\r\n  });\r\n\r\n  var bind = function() {\r\n    self.elements.body.classList.add('imgCropper-dragging');\r\n    self.addEventListeners(self.elements.body, self.gesture.events.move, drag);\r\n    self.addEventListeners(self.elements.body, self.gesture.events.stop, unbind);\r\n  };\r\n\r\n  var unbind = function() {\r\n    self.elements.body.classList.remove('imgCropper-dragging');\r\n    self.removeEventListeners(self.elements.body, self.gesture.events.move, drag);\r\n    self.removeEventListeners(self.elements.body, self.gesture.events.stop, unbind);\r\n  };\r\n\r\n  var drag = function(event) {\r\n    self.dragging.call(self, event);\r\n  };\r\n};\r\n\r\n/**\r\n * Dragging action.\r\n * @param event\r\n */\r\nCropper.prototype.dragging = function(event) {\r\n  var dx, dy, left, p, top;\r\n  event.preventDefault();\r\n  event.stopImmediatePropagation();\r\n\r\n  p = this.getPointerPosition(event); // Cursor position after moving.\r\n\r\n  dx = p.x - this.pointerPosition.x; // Difference (cursor movement) on X axes.\r\n  dy = p.y - this.pointerPosition.y; // Difference (cursor movement) on Y axes.\r\n\r\n  this.pointerPosition = p; // Update cursor position.\r\n\r\n  /**\r\n   * dx > 0 if moving right.\r\n   * dx / clientWidth is the percentage of the wrapper's width it moved over X.\r\n   */\r\n  left = (dx === 0)? null : this.left - dx / this.elements.wrapper.clientWidth;\r\n\r\n  /**\r\n   * dy > 0 if moving down.\r\n   * dy / clientHeight is the percentage of the wrapper's width it moved over Y.\r\n   */\r\n  top = (dy === 0)? null : this.top - dy / this.elements.wrapper.clientHeight;\r\n\r\n  // Move.\r\n  this.setOffset(left, top);\r\n};\r\n\r\n/**\r\n * Set image offset manipulations.\r\n * @param left {number} is a relative number.\r\n * @param top {number} is a relative number.\r\n */\r\nCropper.prototype.setOffset = function(left, top) {\r\n  /**\r\n   * Offset left.\r\n   */\r\n  if (left || left === 0) {\r\n    if (left < 0) { left = 0; }\r\n    if (left > this.width - 1) { left = this.width - 1; }\r\n\r\n    this.elements.container.style.left = (-left * 100).toFixed(2) + '%';\r\n    this.left = left;\r\n    this.data.x = Math.round(left * this.options.width);\r\n  }\r\n\r\n  /**\r\n   * Offset top.\r\n   */\r\n  if (top || top === 0) {\r\n    if (top < 0) { top = 0; }\r\n    if (top > this.height - 1) { top = this.height - 1; }\r\n\r\n    this.elements.container.style.top = (-top * 100).toFixed(2) + '%';\r\n    this.top = top;\r\n    this.data.y = Math.round(top * this.options.height);\r\n  }\r\n};\r\n\r\nCropper.prototype.fitImage = function() {\r\n  var prevWidth, relativeRatio;\r\n\r\n  prevWidth = this.width;\r\n  relativeRatio = this.height / this.width;\r\n\r\n  if (relativeRatio > 1) {\r\n    this.width = 1;\r\n    this.height = relativeRatio;\r\n  } else {\r\n    this.width = 1 / relativeRatio;\r\n    this.height = 1;\r\n  }\r\n\r\n  this.elements.container.style.width = (this.width * 100).toFixed(2) + '%';\r\n  this.elements.container.style.height = (this.height * 100).toFixed(2) + '%';\r\n\r\n  this.data.scale *= this.width / prevWidth;\r\n};\r\n\r\nCropper.prototype.centerImage = function() {\r\n  this.setOffset((this.width - 1) / 2, (this.height - 1) / 2);\r\n};\r\n\r\n/**\r\n * Do a rotation on the image with degrees given.\r\n * @param degrees\r\n */\r\nCropper.prototype.rotateImage = function(degrees) {\r\n  // Only rotate of 90°.\r\n  if (!(degrees !== 0 && degrees % 90 === 0)) {\r\n    throw new Error('Cropper: Support only multiple of 90° for rotation.');\r\n  }\r\n\r\n  // Smallest positive equivalent angle (total rotation).\r\n  this.angle = (this.angle + degrees) % 360;\r\n  if (this.angle < 0) {\r\n    this.angle += 360;\r\n  }\r\n\r\n  // Dimensions are changed?\r\n  if (degrees % 180 !== 0) {\r\n    /**\r\n     * Switch canvas dimensions (as percentages).\r\n     * canvasWidth = @width * this.options.width; canvasHeight = @height * this.options.height\r\n     * To make canvasWidth = canvasHeight (to switch dimensions):\r\n     * => newWidth * this.options.width = @height * this.options.height\r\n     * => newWidth = @height * this.options.height / this.options.width\r\n     * => newWidth = @height * this.imageRatio\r\n     */\r\n    var tempW = this.height * this.imageRatio;\r\n    var tempH = this.width / this.imageRatio;\r\n    this.width = tempW;\r\n    this.height = tempH;\r\n    if (this.width >= 1 && this.height >= 1) {\r\n      this.elements.container.style.width = this.width * 100 + '%';\r\n      this.elements.container.style.height = this.height * 100 + '%';\r\n    } else {\r\n      this.fitImage();\r\n    }\r\n  }\r\n\r\n  var newWidth = 1;\r\n  var newHeight = 1;\r\n\r\n  // Adjust element's (image) dimensions inside the container.\r\n  if (this.angle % 180 !== 0) {\r\n    var ratio = this.height / this.width * this.imageRatio;\r\n    newWidth = ratio;\r\n    newHeight = 1 / ratio;\r\n  }\r\n\r\n  this.elements.image.style.width = newWidth * 100 + '%';\r\n  this.elements.image.style.height = newHeight * 100 + '%';\r\n  this.elements.image.style.left = (1 - newWidth) / 2 * 100 + '%';\r\n  this.elements.image.style.top = (1 - newHeight) / 2 * 100 + '%';\r\n\r\n\r\n  this.elements.image.style.transform = 'rotate(' + this.angle + 'deg)';\r\n  this.elements.image.style.webkitTransform = 'rotate(' + this.angle + 'deg)';\r\n  this.elements.image.style.mozTransform = 'rotate(' + this.angle + 'deg)';\r\n  this.elements.image.style.msTransform = 'rotate(' + this.angle + 'deg)';\r\n  this.elements.image.style.oTransform = 'rotate(' + this.angle + 'deg)';\r\n\r\n  this.centerImage();\r\n  this.data.degrees = this.angle;\r\n};\r\n\r\nCropper.prototype.zoomImage = function(factor) {\r\n  if (factor <= 0 || factor == 1) {\r\n    return;\r\n  }\r\n\r\n  var originalWidth = this.width;\r\n\r\n  if (this.width * factor > 1 && this.height * factor > 1) {\r\n    this.height *= factor;\r\n    this.width *= factor;\r\n    this.elements.container.style.height = (this.height * 100).toFixed(2) + '%';\r\n    this.elements.container.style.width = (this.width * 100).toFixed(2) + '%';\r\n    this.data.scale *= factor;\r\n  } else {\r\n    this.fitImage();\r\n    factor = this.width / originalWidth;\r\n  }\r\n\r\n  /**\r\n   * Keep window center.\r\n   * The offsets are the distances between the image point in the center of the wrapper\r\n   * and each edge of the image, less half the size of the window.\r\n   * Percentage offsets are relative to the container (the wrapper), so half the wrapper\r\n   * is 50% (0.5) and when zooming the distance between any two points in the image\r\n   * grows by 'factor', so the new offsets are:\r\n   *\r\n   * offset = (prev-center-to-edge) * factor - half-window\r\n   *\r\n   */\r\n  var left = (this.left + 0.5) * factor - 0.5;\r\n  var top = (this.top + 0.5) * factor - 0.5;\r\n\r\n  this.setOffset(left, top);\r\n};\r\n\r\nCropper.prototype.cropImage = function() {\r\n  return this.cropHandler();\r\n};\r\n\r\nCropper.prototype.cropHandler = function() {\r\n  var canvas, context;\r\n\r\n  canvas = document.createElement('canvas');\r\n  canvas.height = this.options.height;\r\n  canvas.width = this.options.width;\r\n\r\n  var cx = -canvas.width / 2;\r\n  var cy = -canvas.height / 2;\r\n\r\n  context = canvas.getContext('2d');\r\n  context.translate(-cx,-cy); //move to centre of canvas\r\n  context.rotate(this.data.degrees * Math.PI/180);\r\n  context.scale(this.data.scale, this.data.scale);\r\n\r\n  if(this.data.degrees == 0) { // simple offsets from canvas centre & scale\r\n    context.drawImage(this.elements.image,\r\n      (cx - this.data.x) / this.data.scale,\r\n      (cy - this.data.y) / this.data.scale\r\n    );\r\n  } else if(this.data.degrees == 90) { // swap axis and reverse the new y origin\r\n    context.drawImage(this.elements.image,\r\n      (cy - this.data.y) / this.data.scale,\r\n      (-1 * this.elements.image.naturalHeight) + ((-cx + this.data.x) / this.data.scale)\r\n    );\r\n  } else if(this.data.degrees == 180) { // reverse both origins\r\n    context.drawImage(this.elements.image,\r\n      (-1 * this.elements.image.naturalWidth) + ((-cx + this.data.x) / this.data.scale),\r\n      (-1 * this.elements.image.naturalHeight) + ((-cy + this.data.y) / this.data.scale)\r\n    );\r\n  } else if(this.data.degrees == 270) { // swap axis and reverse the new x origin\r\n    context.drawImage(this.elements.image,\r\n      (-1 * this.elements.image.naturalWidth) + ((-cy + this.data.y) / this.data.scale),\r\n      (cx - this.data.x) / this.data.scale\r\n    );\r\n  }\r\n\r\n  var base64 = canvas.toDataURL('image/jpeg');\r\n  this.events.triggerHandler('Cropped', base64);\r\n  return base64;\r\n};\r\n\r\nCropper.prototype.useHardwareAccelerate = function(element) {\r\n  element.style.perspective = '1000px';\r\n  element.style.backfaceVisibility = 'hidden';\r\n};\r\n\r\nCropper.prototype.extend = function(defaults, options) {\r\n  var target = defaults;\r\n  var defaultsKeys = Object.keys(defaults);\r\n\r\n  defaultsKeys.forEach(function(key, index, keysArray) {\r\n    if (options[key] !== undefined) {\r\n      target[key] = options[key];\r\n    }\r\n  });\r\n\r\n  return target;\r\n};\r\n\r\n/**\r\n * Helper for adding new event listener on element given.\r\n * @param element\r\n * @param eventNames\r\n * @param func\r\n * @param context\r\n */\r\nCropper.prototype.addEventListeners = function(element, eventNames, func, context) {\r\n  eventNames.split(' ').forEach(function(eventName) {\r\n    if (context) {\r\n      element.addEventListener(eventName, func.bind(context), false);\r\n    } else {\r\n      element.addEventListener(eventName, func, false);\r\n    }\r\n  });\r\n};\r\n\r\n/**\r\n * Helper for removing event listener in element given.\r\n * @param element\r\n * @param eventNames\r\n * @param func\r\n * @param context\r\n */\r\nCropper.prototype.removeEventListeners = function(element, eventNames, func, context) {\r\n  eventNames.split(' ').forEach(function(eventName) {\r\n    if (context) {\r\n      element.removeEventListener(eventName, func.bind(context), false);\r\n    } else {\r\n      element.removeEventListener(eventName, func, false);\r\n    }\r\n  });\r\n};\r\n\r\n/**\r\n * Helper for setting pointer position.\r\n * @param {object} event\r\n * @returns {{x: *, y: *}}\r\n */\r\nCropper.prototype.getPointerPosition = function(event) {\r\n  if (this.isTouchEvent(event)) {\r\n    event = event.touches[0];\r\n  }\r\n  return {\r\n    x: event.pageX,\r\n    y: event.pageY\r\n  };\r\n};\r\n/**\r\n * Helper for testing if the event is valid.\r\n * TODO: Comment this magic thing.\r\n * @param event\r\n * @returns {boolean}\r\n */\r\nCropper.prototype.isValidEvent = function(event) {\r\n  if (this.isTouchEvent(event)) {\r\n    return event.changedTouches.length === 1;\r\n  }\r\n  return event.which === 1;\r\n};\r\n\r\n/**\r\n * Helper for testing if the event is touch.\r\n * @param event\r\n * @returns {boolean}\r\n */\r\nCropper.prototype.isTouchEvent = function(event) {\r\n  return /touch/i.test(event.type);\r\n};\r\n\r\n/**\r\n * Helper for adding a timestamp at the end of an URL.\r\n * @param url\r\n * @returns {string}\r\n */\r\nCropper.prototype.addTimestamp = function(url) {\r\n  var timestamp = 'timestamp=' + (new Date()).getTime();\r\n  var sign = '?';\r\n\r\n  if (url.indexOf('?') !== -1) {\r\n    sign = '&';\r\n  }\r\n\r\n  return url.concat(sign, timestamp);\r\n};\r\n/**\r\n * Helper for checking if the given url is cross origin.\r\n * @param url\r\n * @returns {boolean}\r\n */\r\nCropper.prototype.isCrossOrigin = function(url) {\r\n  var parts = url.match();\r\n\r\n  return Boolean(parts && (\r\n      parts[1] !== location.protocol ||\r\n      parts[2] !== location.hostname ||\r\n      parts[3] !== location.port\r\n    ));\r\n};\r\n\r\n/**\r\n * Helper for converting arrayBuffer to base64.\r\n * @param arrayBuffer\r\n * @returns {string}\r\n */\r\nCropper.prototype.base64ArrayBuffer = function(arrayBuffer) {\r\n  var base64 = '';\r\n  var encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\r\n  var bytes = new Uint8Array(arrayBuffer);\r\n  var byteLength = bytes.byteLength;\r\n  var byteRemainder = byteLength % 3;\r\n  var mainLength = byteLength - byteRemainder;\r\n  var a, b, c, d;\r\n  var chunk;\r\n  // Main loop deals with bytes in chunks of 3\r\n  for (var i = 0; i < mainLength; i = i + 3) {\r\n    // Combine the three bytes into a single integer\r\n    chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];\r\n    // Use bitmasks to extract 6-bit segments from the triplet\r\n    a = (chunk & 16515072) >> 18; // 16515072 = (2^6 - 1) << 18\r\n    b = (chunk & 258048) >> 12; // 258048   = (2^6 - 1) << 12\r\n    c = (chunk & 4032) >> 6; // 4032     = (2^6 - 1) << 6\r\n    d = chunk & 63;               // 63       = 2^6 - 1\r\n    // Convert the raw binary segments to the appropriate ASCII encoding\r\n    base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];\r\n  }\r\n  // Deal with the remaining bytes and padding\r\n  if (byteRemainder == 1) {\r\n    chunk = bytes[mainLength];\r\n    a = (chunk & 252) >> 2; // 252 = (2^6 - 1) << 2\r\n    // Set the 4 least significant bits to zero\r\n    b = (chunk & 3) << 4; // 3   = 2^2 - 1\r\n    base64 += encodings[a] + encodings[b] + '==';\r\n  } else if (byteRemainder == 2) {\r\n    chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1];\r\n    a = (chunk & 64512) >> 10; // 64512 = (2^6 - 1) << 10\r\n    b = (chunk & 1008) >> 4; // 1008  = (2^6 - 1) << 4\r\n    // Set the 2 least significant bits to zero\r\n    c = (chunk & 15) << 2; // 15    = 2^4 - 1\r\n    base64 += encodings[a] + encodings[b] + encodings[c] + '=';\r\n  }\r\n  return base64;\r\n};\r\n\r\n/**\r\n * Helper for events handler.\r\n */\r\nCropper.prototype.events = new function() {\r\n  var _triggers = {};\r\n\r\n  this.on = function(event, callback) {\r\n    if (!_triggers[event]) {\r\n      _triggers[event] = [];\r\n    }\r\n    _triggers[event].push(callback);\r\n  };\r\n\r\n  this.triggerHandler = function(event, params) {\r\n    if (_triggers[event]) {\r\n      for (var i in _triggers[event]) {\r\n        _triggers[event][i](params);\r\n      }\r\n    }\r\n  };\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW1hZ2VDcm9wcGVyLmpzPzJlYzciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9FQUFvRTtBQUNwRSxrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7O0FBRXJDLG9DQUFvQztBQUNwQyxvQ0FBb0M7O0FBRXBDLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixVQUFVO0FBQzdCLGdDQUFnQyx1QkFBdUI7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0IsZ0NBQWdDLHVCQUF1Qjs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsbUNBQW1DO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxvQ0FBb0M7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLG9DQUFvQztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsK0JBQStCO0FBQy9CLDRCQUE0QjtBQUM1QixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsR0FBRztBQUNIO0FBQ0EsOEJBQThCO0FBQzlCLDRCQUE0QjtBQUM1QjtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IENyb3BwZXI7XHJcblxyXG4vKipcclxuICogQ3JvcHBlci5cclxuICogQHBhcmFtIG9wdGlvbnNcclxuICogQHJldHVybnMge0Nyb3BwZXJ9XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gQ3JvcHBlcihvcHRpb25zKSB7XHJcblxyXG4gIGlmICghb3B0aW9ucy5pbWFnZVVybCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdDcm9wcGVyOiBObyBpbWFnZSB1cmwgZ2l2ZW4uJyk7XHJcbiAgfVxyXG5cclxuICB0aGlzLmlzUmVhZHkgPSBmYWxzZTtcclxuICB0aGlzLm9yaWdpbmFsVXJsID0gb3B0aW9ucy5pbWFnZVVybDtcclxuXHJcbiAgLy8gRGVmYXVsdCBvcHRpb25zLlxyXG4gIHZhciBkZWZhdWx0cyA9IHtcclxuICAgIGNoZWNrQ3Jvc3NPcmlnaW46IGZhbHNlLFxyXG4gICAgYXBpQ2FsbGJhY2s6IHVuZGVmaW5lZCxcclxuICAgIGNyb3BDYWxsYmFjazogdW5kZWZpbmVkLFxyXG4gICAgd2lkdGg6IDQwMCxcclxuICAgIGhlaWdodDogMzAwLFxyXG4gICAgaW1hZ2VVcmw6IHVuZGVmaW5lZCxcclxuICAgIHRhcmdldDogdW5kZWZpbmVkLFxyXG4gICAgc2hvd0NvbnRyb2xzOiB0cnVlLFxyXG4gICAgZml0T25Jbml0OiBmYWxzZSxcclxuICAgIGNlbnRlck9uSW5pdDogZmFsc2UsXHJcbiAgICB6b29tU3RlcDogMC4xLFxyXG4gICAgYWN0aW9uTGFiZWxzOiB7XHJcbiAgICAgIHJvdGF0ZUxlZnQ6ICcgPCAnLFxyXG4gICAgICByb3RhdGVSaWdodDogJyA+ICcsXHJcbiAgICAgIHpvb21JbjogJyArICcsXHJcbiAgICAgIHpvb21PdXQ6ICcgLSAnLFxyXG4gICAgICBmaXQ6ICcoZml0KScsXHJcbiAgICAgIGNyb3A6ICdbY3JvcF0nXHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8gU2V0dXAgb3B0aW9ucy5cclxuICB0aGlzLm9wdGlvbnMgPSB0aGlzLmV4dGVuZChkZWZhdWx0cywgb3B0aW9ucyk7XHJcblxyXG4gIC8vIFNldHVwIGdlc3R1cmUgZXZlbnRzLlxyXG4gIHRoaXMuZ2VzdHVyZSA9IHt9O1xyXG4gIHRoaXMuZ2VzdHVyZS5ldmVudHMgPSB7XHJcbiAgICBzdGFydDogJ3RvdWNoc3RhcnQgbW91c2Vkb3duJyxcclxuICAgIG1vdmU6ICd0b3VjaG1vdmUgbW91c2Vtb3ZlJyxcclxuICAgIHN0b3A6ICd0b3VjaGVuZCBtb3VzZXVwJ1xyXG4gIH07XHJcblxyXG4gIHRoaXMucG9pbnRlclBvc2l0aW9uID0gdW5kZWZpbmVkO1xyXG5cclxuICAvLyBTZXR1cCBiYXNpYyBlbGVtZW50cy5cclxuICB0aGlzLmVsZW1lbnRzID0ge1xyXG4gICAgdGFyZ2V0OiBvcHRpb25zLnRhcmdldCxcclxuICAgIGJvZHk6IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdib2R5JylbMF1cclxuICB9O1xyXG5cclxuICB0aGlzLmJ1aWxkRE9NKCk7XHJcbiAgdGhpcy51c2VIYXJkd2FyZUFjY2VsZXJhdGUodGhpcy5lbGVtZW50cy5pbWFnZSk7XHJcblxyXG4gIC8vIEFQSSBTZXR1cDpcclxuICB2YXIgYXBpID0ge1xyXG4gICAgY3JvcDogdGhpcy5jcm9wSW1hZ2UuYmluZCh0aGlzKSxcclxuICAgIGZpdDogdGhpcy5hcHBseUZpdC5iaW5kKHRoaXMpLFxyXG4gICAgcm90YXRlOiB0aGlzLmFwcGx5Um90YXRpb24uYmluZCh0aGlzKSxcclxuICAgIHpvb21JbjogdGhpcy5hcHBseVpvb21Jbi5iaW5kKHRoaXMpLFxyXG4gICAgem9vbU91dDogdGhpcy5hcHBseVpvb21PdXQuYmluZCh0aGlzKSxcclxuICAgIHJlbW92ZTogdGhpcy5yZW1vdmUuYmluZCh0aGlzKVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemF0aW9uIG9mIHRoZSBDcm9wcGVyIChkaW1lbnNpb25zLCBldmVudCBiaW5kaW5nLi4uKS5cclxuICAgKi9cclxuICB0aGlzLmV2ZW50cy5vbignSW1hZ2VSZWFkeScsIHRoaXMuaW5pdGlhbGl6ZS5iaW5kKHRoaXMpKTtcclxuXHJcbiAgLyoqXHJcbiAgICogRXhlY3V0ZSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIGNyb3BwZWQuXHJcbiAgICovXHJcbiAgaWYgKHRoaXMub3B0aW9ucy5jcm9wQ2FsbGJhY2spIHtcclxuICAgIHRoaXMuZXZlbnRzLm9uKCdDcm9wcGVkJywgZnVuY3Rpb24oYmFzZTY0KSB7XHJcbiAgICAgIHRoaXMub3B0aW9ucy5jcm9wQ2FsbGJhY2soYmFzZTY0KTtcclxuICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZW5kIEFQSSB3aGVuIGltYWdlIGlzIHJlYWR5IGlmIHJlYWR5Q2FsbGJhY2sgaXMgdHJ1ZS5cclxuICAgKi9cclxuICBpZiAodGhpcy5vcHRpb25zLmFwaUNhbGxiYWNrKSB7XHJcbiAgICB0aGlzLmV2ZW50cy5vbignSW1hZ2VSZWFkeScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICB0aGlzLm9wdGlvbnMuYXBpQ2FsbGJhY2soYXBpKTtcclxuICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgfVxyXG59XHJcblxyXG5Dcm9wcGVyLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7XHJcbiAgdGhpcy5zZXREaW1lbnNpb25zKCk7XHJcblxyXG4gIGlmICh0aGlzLmltYWdlSGFzVG9GaXQoKSkge1xyXG4gICAgdGhpcy5maXRJbWFnZSgpO1xyXG4gICAgdGhpcy5jZW50ZXJJbWFnZSgpO1xyXG4gIH1cclxuICB0aGlzLmluaXRpYWxpemVHZXN0dXJlKCk7XHJcblxyXG4gIGlmICh0aGlzLm9wdGlvbnMuY2VudGVyT25Jbml0KSB7XHJcbiAgICB0aGlzLmNlbnRlckltYWdlKCk7XHJcbiAgfVxyXG5cclxuICBpZiAodGhpcy5vcHRpb25zLnNob3dDb250cm9scykge1xyXG4gICAgdGhpcy5iaW5kQ29udHJvbHMoKTtcclxuICB9XHJcbn07XHJcblxyXG5Dcm9wcGVyLnByb3RvdHlwZS5iaW5kQ29udHJvbHMgPSBmdW5jdGlvbigpIHtcclxuICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgdGhpcy5lbGVtZW50cy5jb250cm9scy5yb3RhdGVMZWZ0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oKSB7XHJcbiAgICBzZWxmLmFwcGx5Um90YXRpb24oLTkwKTtcclxuICB9KTtcclxuICB0aGlzLmVsZW1lbnRzLmNvbnRyb2xzLnJvdGF0ZVJpZ2h0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oKSB7XHJcbiAgICBzZWxmLmFwcGx5Um90YXRpb24oOTApO1xyXG4gIH0pO1xyXG4gIHRoaXMuZWxlbWVudHMuY29udHJvbHMuem9vbUluLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oKSB7XHJcbiAgICBzZWxmLmFwcGx5Wm9vbUluKHNlbGYuem9vbUluRmFjdG9yKTtcclxuICB9KTtcclxuICB0aGlzLmVsZW1lbnRzLmNvbnRyb2xzLnpvb21PdXQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpIHtcclxuICAgIHNlbGYuYXBwbHlab29tT3V0KHNlbGYuem9vbU91dEZhY3Rvcik7XHJcbiAgfSk7XHJcbiAgdGhpcy5lbGVtZW50cy5jb250cm9scy5maXQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmFwcGx5Rml0LmJpbmQodGhpcykpO1xyXG4gIHRoaXMuZWxlbWVudHMuY29udHJvbHMuY3JvcC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuY3JvcEltYWdlLmJpbmQodGhpcykpO1xyXG59O1xyXG5cclxuQ3JvcHBlci5wcm90b3R5cGUuYXBwbHlSb3RhdGlvbiA9IGZ1bmN0aW9uKGRlZ3JlZSkge1xyXG4gIHRoaXMucm90YXRlSW1hZ2UoZGVncmVlKTtcclxufTtcclxuXHJcbkNyb3BwZXIucHJvdG90eXBlLmFwcGx5Wm9vbUluID0gZnVuY3Rpb24oem9vbSkge1xyXG4gIHRoaXMuem9vbUltYWdlKDEgKyBwYXJzZUZsb2F0KHpvb20pKTtcclxufTtcclxuQ3JvcHBlci5wcm90b3R5cGUuYXBwbHlab29tT3V0ID0gZnVuY3Rpb24oem9vbSkge1xyXG4gIHRoaXMuem9vbUltYWdlKDEgLyAoIDEgKyBwYXJzZUZsb2F0KHpvb20pKSk7XHJcbn07XHJcblxyXG5Dcm9wcGVyLnByb3RvdHlwZS5hcHBseUZpdCA9IGZ1bmN0aW9uKCkge1xyXG4gIHRoaXMuZml0SW1hZ2UoKTtcclxuICB0aGlzLmNlbnRlckltYWdlKCk7XHJcbn07XHJcblxyXG5Dcm9wcGVyLnByb3RvdHlwZS5pbWFnZUhhc1RvRml0ID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHRoaXMuZWxlbWVudHMuaW1hZ2UubmF0dXJhbFdpZHRoIDwgdGhpcy5vcHRpb25zLndpZHRoIHx8XHJcbiAgICB0aGlzLmVsZW1lbnRzLmltYWdlLm5hdHVyYWxIZWlnaHQgPCB0aGlzLm9wdGlvbnMuaGVpZ2h0IHx8XHJcbiAgICB0aGlzLndpZHRoIDwgMSB8fCB0aGlzLmhlaWdodCA8IDEgfHwgLy8gMSBtZWFucyAxMDAlLlxyXG4gICAgdGhpcy5vcHRpb25zLmZpdE9uSW5pdDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBCdWlsZCBET00gZWxlbWVudCBmb3IgdGhlIENyb3BwZXIgYXBwZW5kZWQgaW4gdGhlIHRhcmdldGVkIGVsZW1lbnQuXHJcbiAqL1xyXG5Dcm9wcGVyLnByb3RvdHlwZS5idWlsZERPTSA9IGZ1bmN0aW9uKCkge1xyXG4gIHZhciBfZWxlbWVudHM7XHJcbiAgX2VsZW1lbnRzID0gdGhpcy5lbGVtZW50cztcclxuXHJcbiAgLy8gV3JhcHBlci5cclxuICBfZWxlbWVudHMud3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gIF9lbGVtZW50cy53cmFwcGVyLmNsYXNzTmFtZSA9ICdpbWdDcm9wcGVyLXdyYXBwZXInO1xyXG5cclxuICAvLyBDb250YWluZXIuXHJcbiAgX2VsZW1lbnRzLmNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gIF9lbGVtZW50cy5jb250YWluZXIuY2xhc3NOYW1lID0gJ2ltZ0Nyb3BwZXItY29udGFpbmVyJztcclxuXHJcbiAgLy8gSW1hZ2UuXHJcbiAgX2VsZW1lbnRzLmltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XHJcbiAgX2VsZW1lbnRzLmltYWdlLmNsYXNzTmFtZSA9ICdpbWdDcm9wcGVyLWltYWdlJztcclxuXHJcblxyXG4gIC8vIFRhcmdldCAtPiBXcmFwcGVyIC0+IENvbnRhaW5lciAtPiBJbWFnZVxyXG4gIF9lbGVtZW50cy5jb250YWluZXIuYXBwZW5kQ2hpbGQoX2VsZW1lbnRzLmltYWdlKTtcclxuICBfZWxlbWVudHMud3JhcHBlci5hcHBlbmRDaGlsZChfZWxlbWVudHMuY29udGFpbmVyKTtcclxuICBfZWxlbWVudHMudGFyZ2V0LmFwcGVuZENoaWxkKF9lbGVtZW50cy53cmFwcGVyKTtcclxuXHJcbiAgaWYgKCF0aGlzLm9wdGlvbnMuc2hvd0NvbnRyb2xzKSB7XHJcbiAgICByZXR1cm4gdGhpcy5sb2FkSW1hZ2UoKTtcclxuICB9XHJcblxyXG4gIC8vIENvbnRyb2xzLlxyXG4gIF9lbGVtZW50cy5jb250cm9scyA9IHt9O1xyXG4gIF9lbGVtZW50cy5jb250cm9scy53cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgX2VsZW1lbnRzLmNvbnRyb2xzLndyYXBwZXIuY2xhc3NOYW1lID0gJ2ltZ0Nyb3BwZXItY29udHJvbHMnO1xyXG5cclxuICBfZWxlbWVudHMuY29udHJvbHMucm90YXRlTGVmdCA9IHRoaXMuX2J1aWxkQ29udHJvbCh0aGlzLm9wdGlvbnMuYWN0aW9uTGFiZWxzLnJvdGF0ZUxlZnQpO1xyXG4gIF9lbGVtZW50cy5jb250cm9scy5yb3RhdGVSaWdodCA9IHRoaXMuX2J1aWxkQ29udHJvbCh0aGlzLm9wdGlvbnMuYWN0aW9uTGFiZWxzLnJvdGF0ZVJpZ2h0KTtcclxuICBfZWxlbWVudHMuY29udHJvbHMuem9vbUluID0gdGhpcy5fYnVpbGRDb250cm9sKHRoaXMub3B0aW9ucy5hY3Rpb25MYWJlbHMuem9vbUluKTtcclxuICBfZWxlbWVudHMuY29udHJvbHMuem9vbU91dCA9IHRoaXMuX2J1aWxkQ29udHJvbCh0aGlzLm9wdGlvbnMuYWN0aW9uTGFiZWxzLnpvb21PdXQpO1xyXG4gIF9lbGVtZW50cy5jb250cm9scy5maXQgPSB0aGlzLl9idWlsZENvbnRyb2wodGhpcy5vcHRpb25zLmFjdGlvbkxhYmVscy5maXQpO1xyXG5cclxuICBfZWxlbWVudHMuY29udHJvbHMuY3JvcCA9IHRoaXMuX2J1aWxkQ29udHJvbCh0aGlzLm9wdGlvbnMuYWN0aW9uTGFiZWxzLmNyb3ApO1xyXG5cclxuXHQvLyBUYXJnZXQgLT4gV3JhcHBlciAtPiBidXR0b25zXHJcblx0Ly9kLnBhcmlzaSBub24gcGFzc2FuZG8gbGEgcmVsYXRpdmEgbGFiZWwgw6ggb3JhIHBvc3NpYmlsZSBuYXNjb25kZXJlIHVuIGJvdHRvbmVcclxuXHRpZih0aGlzLm9wdGlvbnMuYWN0aW9uTGFiZWxzLnJvdGF0ZUxlZnQpe1xyXG5cdFx0X2VsZW1lbnRzLmNvbnRyb2xzLndyYXBwZXIuYXBwZW5kQ2hpbGQoX2VsZW1lbnRzLmNvbnRyb2xzLnJvdGF0ZUxlZnQpO1xyXG5cdH1cclxuXHRpZih0aGlzLm9wdGlvbnMuYWN0aW9uTGFiZWxzLnpvb21PdXQpe1xyXG5cdFx0X2VsZW1lbnRzLmNvbnRyb2xzLndyYXBwZXIuYXBwZW5kQ2hpbGQoX2VsZW1lbnRzLmNvbnRyb2xzLnpvb21PdXQpO1xyXG5cdH1cclxuXHRpZih0aGlzLm9wdGlvbnMuYWN0aW9uTGFiZWxzLmZpdCl7XHJcblx0XHRfZWxlbWVudHMuY29udHJvbHMud3JhcHBlci5hcHBlbmRDaGlsZChfZWxlbWVudHMuY29udHJvbHMuZml0KTtcclxuXHR9XHJcblx0aWYodGhpcy5vcHRpb25zLmFjdGlvbkxhYmVscy5jcm9wKXtcclxuXHRcdF9lbGVtZW50cy5jb250cm9scy53cmFwcGVyLmFwcGVuZENoaWxkKF9lbGVtZW50cy5jb250cm9scy5jcm9wKTtcclxuXHR9XHJcblx0aWYodGhpcy5vcHRpb25zLmFjdGlvbkxhYmVscy56b29tSW4pe1xyXG5cdFx0X2VsZW1lbnRzLmNvbnRyb2xzLndyYXBwZXIuYXBwZW5kQ2hpbGQoX2VsZW1lbnRzLmNvbnRyb2xzLnpvb21Jbik7XHJcblx0fVxyXG5cdGlmKHRoaXMub3B0aW9ucy5hY3Rpb25MYWJlbHMucm90YXRlUmlnaHQpe1xyXG5cdFx0X2VsZW1lbnRzLmNvbnRyb2xzLndyYXBwZXIuYXBwZW5kQ2hpbGQoX2VsZW1lbnRzLmNvbnRyb2xzLnJvdGF0ZVJpZ2h0KTtcclxuXHR9XHJcblxyXG5cdF9lbGVtZW50cy50YXJnZXQuYXBwZW5kQ2hpbGQoX2VsZW1lbnRzLmNvbnRyb2xzLndyYXBwZXIpO1xyXG4gIHRoaXMubG9hZEltYWdlKCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQnVpbGQgY29udHJvbCBlbGVtZW50LlxyXG4gKiBAcGFyYW0gbGFiZWxcclxuICogQHJldHVybnMge0VsZW1lbnR9XHJcbiAqL1xyXG5Dcm9wcGVyLnByb3RvdHlwZS5fYnVpbGRDb250cm9sID0gZnVuY3Rpb24obGFiZWwpIHtcclxuICB2YXIgY29udHJvbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xyXG4gIGNvbnRyb2wuc2V0QXR0cmlidXRlKCd0eXBlJywgJ2J1dHRvbicpO1xyXG4gIGNvbnRyb2wuaW5uZXJIVE1MID0gbGFiZWw7XHJcblxyXG4gIHJldHVybiBjb250cm9sO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSBhbGwgRE9NIGVsZW1lbnQgcGFydHMgb2YgdGhlIENyb3BwZXIuXHJcbiAqL1xyXG5Dcm9wcGVyLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzO1xyXG4gIGVsZW1lbnRzLnRhcmdldC5yZW1vdmVDaGlsZChlbGVtZW50cy53cmFwcGVyKTtcclxuICBpZiAodGhpcy5vcHRpb25zLnNob3dDb250cm9scykgZWxlbWVudHMudGFyZ2V0LnJlbW92ZUNoaWxkKGVsZW1lbnRzLmNvbnRyb2xzLndyYXBwZXIpO1xyXG59O1xyXG5cclxuQ3JvcHBlci5wcm90b3R5cGUuY2hhbmdlSW1hZ2UgPSBmdW5jdGlvbihuZXdJbWFnZVVybCkge1xyXG4gIGlmICh0eXBlb2YgbmV3SW1hZ2VVcmwgPT09ICd1bmRlZmluZWQnIHx8IG5ld0ltYWdlVXJsID09PSAnJykge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgdGhpcy5vcmlnaW5hbFVybCA9IG5ld0ltYWdlVXJsO1xyXG4gIHRoaXMubG9hZEltYWdlKCk7XHJcbn07XHJcblxyXG5Dcm9wcGVyLnByb3RvdHlwZS5sb2FkSW1hZ2UgPSBmdW5jdGlvbigpIHtcclxuICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgdmFyIHhocjtcclxuXHJcbiAgLy8gWE1MSHR0cFJlcXVlc3QgZGlzYWxsb3dzIHRvIG9wZW4gYSBEYXRhIFVSTCBpbiBzb21lIGJyb3dzZXJzIGxpa2UgSUUxMSBhbmQgU2FmYXJpLlxyXG4gIGlmICgvXmRhdGFcXDovLnRlc3QodGhpcy5vcmlnaW5hbFVybCkpIHtcclxuICAgIHRoaXMub3JpZ2luYWxCYXNlNjQgPSB0aGlzLm9yaWdpbmFsVXJsO1xyXG4gICAgcmV0dXJuIHRoaXMuc2V0dXBJbWFnZVNSQygpO1xyXG4gIH1cclxuXHJcbiAgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgeGhyLm9uZXJyb3IgPSB4aHIub25hYm9ydCA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XHJcbiAgICBzZWxmLm9yaWdpbmFsQmFzZTY0ID0gc2VsZi5vcmlnaW5hbFVybDtcclxuICAgIHNlbGYuc2V0dXBJbWFnZVNSQygpO1xyXG4gIH07XHJcblxyXG4gIC8vIE5lZWQgdG8gaGF2ZSBwcm9wZXIgc2V0cyBvZiAnQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luJyBvbiB0aGUgcmVxdWVzdGVkIHJlc291cmNlIHNlcnZlci5cclxuICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XHJcbiAgICBzZWxmLm9yaWdpbmFsQXJyYXlCdWZmZXIgPSB0aGlzLnJlc3BvbnNlO1xyXG4gICAgc2VsZi5vcmlnaW5hbEJhc2U2NCA9ICdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LCcgKyBzZWxmLmJhc2U2NEFycmF5QnVmZmVyKHRoaXMucmVzcG9uc2UpO1xyXG4gICAgc2VsZi5zZXR1cEltYWdlU1JDKCk7XHJcbiAgfTtcclxuICB4aHIub3BlbignZ2V0JywgdGhpcy5vcmlnaW5hbFVybCwgdHJ1ZSk7XHJcbiAgLy94aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ2ltYWdlL2pwZycpOyAvLyBUT0RPOiBBdXRvIGRldGVybWluZSB0aGUgaW1hZ2UgTUlNRSdzIHR5cGUuXHJcbiAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XHJcbiAgeGhyLnNlbmQoKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBjcm9zc09yaWdpbnMgYW5kIHNldHVwIGltYWdlIHNyYy5cclxuICovXHJcbkNyb3BwZXIucHJvdG90eXBlLnNldHVwSW1hZ2VTUkMgPSBmdW5jdGlvbigpIHtcclxuICB2YXIgX2ltYWdlID0gdGhpcy5lbGVtZW50cy5pbWFnZTtcclxuXHJcbiAgaWYgKHRoaXMub3B0aW9ucy5jaGVja0Nyb3NzT3JpZ2luICYmIHRoaXMuaXNDcm9zc09yaWdpbih0aGlzLm9yaWdpbmFsVXJsKSkge1xyXG4gICAgdGhpcy5jcm9zc09yaWdpbiA9IF9pbWFnZS5jcm9zc09yaWdpbjtcclxuXHJcbiAgICBpZiAodGhpcy5jcm9zc09yaWdpbikge1xyXG4gICAgICB0aGlzLmNyb3NzT3JpZ2luID0gdGhpcy5vcmlnaW5hbFVybDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJztcclxuXHJcbiAgICAgIC8vIEJ1c3QgY2FjaGUgd2l0aCBhIHRpbWVzdGFtcC5cclxuICAgICAgdGhpcy5jcm9zc09yaWdpblVybCA9IHRoaXMuYWRkVGltZXN0YW1wKHRoaXMub3JpZ2luYWxVcmwpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKHRoaXMuY3Jvc3NPcmlnaW4pIHtcclxuICAgIHRoaXMuZWxlbWVudHMuaW1hZ2UuY3Jvc3NPcmlnaW4gPSB0aGlzLmNyb3NzT3JpZ2luO1xyXG4gIH1cclxuXHJcbiAgLy8gU2V0dXAgaW1hZ2Ugc3JjLlxyXG4gIHRoaXMuZWxlbWVudHMuaW1hZ2Uuc3JjID0gdGhpcy5jcm9zc09yaWdpblVybCB8fCB0aGlzLm9yaWdpbmFsVXJsOyAvLyBOZWVkIHRvIHZlcmlmeS5cclxuICAvL3RoaXMuZWxlbWVudHMuaW1hZ2Uuc3JjID0gdGhpcy5vcmlnaW5hbEJhc2U2NDsgLy8gTmVlZCB0byB2ZXJpZnkuXHJcblxyXG4gIC8vIFdhaXRpbmcgdGhlIGltYWdlIGFzIGxvYWRlZCB0byB0cmlnZ2VyIGV2ZW50LlxyXG4gIHRoaXMuZWxlbWVudHMuaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmV2ZW50cy50cmlnZ2VySGFuZGxlcignSW1hZ2VSZWFkeScpO1xyXG4gIH0uYmluZCh0aGlzKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXQgZGltZW5zaW9ucy5cclxuICovXHJcbkNyb3BwZXIucHJvdG90eXBlLnNldERpbWVuc2lvbnMgPSBmdW5jdGlvbigpIHtcclxuICB0aGlzLnpvb21JbkZhY3RvciA9IDEgKyBwYXJzZUZsb2F0KHRoaXMub3B0aW9ucy56b29tU3RlcCk7XHJcbiAgdGhpcy56b29tT3V0RmFjdG9yID0gMSAvIHRoaXMuem9vbUluRmFjdG9yO1xyXG5cclxuICB0aGlzLmltYWdlUmF0aW8gPSB0aGlzLm9wdGlvbnMuaGVpZ2h0IC8gdGhpcy5vcHRpb25zLndpZHRoO1xyXG4gIHRoaXMud2lkdGggPSB0aGlzLmVsZW1lbnRzLmltYWdlLm5hdHVyYWxXaWR0aCAvIHRoaXMub3B0aW9ucy53aWR0aDtcclxuICB0aGlzLmhlaWdodCA9IHRoaXMuZWxlbWVudHMuaW1hZ2UubmF0dXJhbEhlaWdodCAvIHRoaXMub3B0aW9ucy5oZWlnaHQ7XHJcbiAgdGhpcy5sZWZ0ID0gMDtcclxuICB0aGlzLnRvcCA9IDA7XHJcbiAgdGhpcy5hbmdsZSA9IDA7XHJcbiAgdGhpcy5kYXRhID0ge1xyXG4gICAgc2NhbGU6IDEsXHJcbiAgICBkZWdyZWVzOiAwLFxyXG4gICAgeDogMCxcclxuICAgIHk6IDAsXHJcbiAgICB3OiB0aGlzLm9wdGlvbnMud2lkdGgsXHJcbiAgICBoOiB0aGlzLm9wdGlvbnMuaGVpZ2h0XHJcbiAgfTtcclxuXHJcbiAgLy8gQ29udGFpbmVyLlxyXG4gIHRoaXMuZWxlbWVudHMuY29udGFpbmVyLnN0eWxlLndpZHRoID0gdGhpcy53aWR0aCAqIDEwMCArICclJztcclxuICB0aGlzLmVsZW1lbnRzLmNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodCAqIDEwMCArICclJztcclxuICB0aGlzLmVsZW1lbnRzLmNvbnRhaW5lci5zdHlsZS50b3AgPSAwO1xyXG4gIHRoaXMuZWxlbWVudHMuY29udGFpbmVyLnN0eWxlLmxlZnQgPSAwO1xyXG5cclxuICAvLyBXcmFwcGVyLlxyXG4gIHRoaXMuZWxlbWVudHMud3JhcHBlci5zdHlsZS5oZWlnaHQgPSAnYXV0byc7XHJcbiAgdGhpcy5lbGVtZW50cy53cmFwcGVyLnN0eWxlLndpZHRoID0gJzEwMCUnO1xyXG4gIHRoaXMuZWxlbWVudHMud3JhcHBlci5zdHlsZS5wYWRkaW5nVG9wID0gKHRoaXMuaW1hZ2VSYXRpbyAqIDEwMCkgKyAnJSc7XHJcblxyXG4gIHRoaXMuaXNSZWFkeSA9IHRydWU7XHJcbn07XHJcblxyXG4vKipcclxuICogSW1hZ2Ugc2hvdWxkIGJlIGFscmVhZHkgbG9hZGVkLlxyXG4gKi9cclxuQ3JvcHBlci5wcm90b3R5cGUuaW5pdGlhbGl6ZUdlc3R1cmUgPSBmdW5jdGlvbigpIHtcclxuICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgdGhpcy5hZGRFdmVudExpc3RlbmVycyh0aGlzLmVsZW1lbnRzLmltYWdlLCB0aGlzLmdlc3R1cmUuZXZlbnRzLnN0YXJ0LCBmdW5jdGlvbihldmVudCkge1xyXG4gICAgaWYgKHNlbGYuaXNSZWFkeSAmJiBzZWxmLmlzVmFsaWRFdmVudChldmVudCkpIHtcclxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XHJcbiAgICAgIHNlbGYucG9pbnRlclBvc2l0aW9uID0gc2VsZi5nZXRQb2ludGVyUG9zaXRpb24oZXZlbnQpO1xyXG4gICAgICBiaW5kKCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIHZhciBiaW5kID0gZnVuY3Rpb24oKSB7XHJcbiAgICBzZWxmLmVsZW1lbnRzLmJvZHkuY2xhc3NMaXN0LmFkZCgnaW1nQ3JvcHBlci1kcmFnZ2luZycpO1xyXG4gICAgc2VsZi5hZGRFdmVudExpc3RlbmVycyhzZWxmLmVsZW1lbnRzLmJvZHksIHNlbGYuZ2VzdHVyZS5ldmVudHMubW92ZSwgZHJhZyk7XHJcbiAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXJzKHNlbGYuZWxlbWVudHMuYm9keSwgc2VsZi5nZXN0dXJlLmV2ZW50cy5zdG9wLCB1bmJpbmQpO1xyXG4gIH07XHJcblxyXG4gIHZhciB1bmJpbmQgPSBmdW5jdGlvbigpIHtcclxuICAgIHNlbGYuZWxlbWVudHMuYm9keS5jbGFzc0xpc3QucmVtb3ZlKCdpbWdDcm9wcGVyLWRyYWdnaW5nJyk7XHJcbiAgICBzZWxmLnJlbW92ZUV2ZW50TGlzdGVuZXJzKHNlbGYuZWxlbWVudHMuYm9keSwgc2VsZi5nZXN0dXJlLmV2ZW50cy5tb3ZlLCBkcmFnKTtcclxuICAgIHNlbGYucmVtb3ZlRXZlbnRMaXN0ZW5lcnMoc2VsZi5lbGVtZW50cy5ib2R5LCBzZWxmLmdlc3R1cmUuZXZlbnRzLnN0b3AsIHVuYmluZCk7XHJcbiAgfTtcclxuXHJcbiAgdmFyIGRyYWcgPSBmdW5jdGlvbihldmVudCkge1xyXG4gICAgc2VsZi5kcmFnZ2luZy5jYWxsKHNlbGYsIGV2ZW50KTtcclxuICB9O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIERyYWdnaW5nIGFjdGlvbi5cclxuICogQHBhcmFtIGV2ZW50XHJcbiAqL1xyXG5Dcm9wcGVyLnByb3RvdHlwZS5kcmFnZ2luZyA9IGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgdmFyIGR4LCBkeSwgbGVmdCwgcCwgdG9wO1xyXG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XHJcblxyXG4gIHAgPSB0aGlzLmdldFBvaW50ZXJQb3NpdGlvbihldmVudCk7IC8vIEN1cnNvciBwb3NpdGlvbiBhZnRlciBtb3ZpbmcuXHJcblxyXG4gIGR4ID0gcC54IC0gdGhpcy5wb2ludGVyUG9zaXRpb24ueDsgLy8gRGlmZmVyZW5jZSAoY3Vyc29yIG1vdmVtZW50KSBvbiBYIGF4ZXMuXHJcbiAgZHkgPSBwLnkgLSB0aGlzLnBvaW50ZXJQb3NpdGlvbi55OyAvLyBEaWZmZXJlbmNlIChjdXJzb3IgbW92ZW1lbnQpIG9uIFkgYXhlcy5cclxuXHJcbiAgdGhpcy5wb2ludGVyUG9zaXRpb24gPSBwOyAvLyBVcGRhdGUgY3Vyc29yIHBvc2l0aW9uLlxyXG5cclxuICAvKipcclxuICAgKiBkeCA+IDAgaWYgbW92aW5nIHJpZ2h0LlxyXG4gICAqIGR4IC8gY2xpZW50V2lkdGggaXMgdGhlIHBlcmNlbnRhZ2Ugb2YgdGhlIHdyYXBwZXIncyB3aWR0aCBpdCBtb3ZlZCBvdmVyIFguXHJcbiAgICovXHJcbiAgbGVmdCA9IChkeCA9PT0gMCk/IG51bGwgOiB0aGlzLmxlZnQgLSBkeCAvIHRoaXMuZWxlbWVudHMud3JhcHBlci5jbGllbnRXaWR0aDtcclxuXHJcbiAgLyoqXHJcbiAgICogZHkgPiAwIGlmIG1vdmluZyBkb3duLlxyXG4gICAqIGR5IC8gY2xpZW50SGVpZ2h0IGlzIHRoZSBwZXJjZW50YWdlIG9mIHRoZSB3cmFwcGVyJ3Mgd2lkdGggaXQgbW92ZWQgb3ZlciBZLlxyXG4gICAqL1xyXG4gIHRvcCA9IChkeSA9PT0gMCk/IG51bGwgOiB0aGlzLnRvcCAtIGR5IC8gdGhpcy5lbGVtZW50cy53cmFwcGVyLmNsaWVudEhlaWdodDtcclxuXHJcbiAgLy8gTW92ZS5cclxuICB0aGlzLnNldE9mZnNldChsZWZ0LCB0b3ApO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNldCBpbWFnZSBvZmZzZXQgbWFuaXB1bGF0aW9ucy5cclxuICogQHBhcmFtIGxlZnQge251bWJlcn0gaXMgYSByZWxhdGl2ZSBudW1iZXIuXHJcbiAqIEBwYXJhbSB0b3Age251bWJlcn0gaXMgYSByZWxhdGl2ZSBudW1iZXIuXHJcbiAqL1xyXG5Dcm9wcGVyLnByb3RvdHlwZS5zZXRPZmZzZXQgPSBmdW5jdGlvbihsZWZ0LCB0b3ApIHtcclxuICAvKipcclxuICAgKiBPZmZzZXQgbGVmdC5cclxuICAgKi9cclxuICBpZiAobGVmdCB8fCBsZWZ0ID09PSAwKSB7XHJcbiAgICBpZiAobGVmdCA8IDApIHsgbGVmdCA9IDA7IH1cclxuICAgIGlmIChsZWZ0ID4gdGhpcy53aWR0aCAtIDEpIHsgbGVmdCA9IHRoaXMud2lkdGggLSAxOyB9XHJcblxyXG4gICAgdGhpcy5lbGVtZW50cy5jb250YWluZXIuc3R5bGUubGVmdCA9ICgtbGVmdCAqIDEwMCkudG9GaXhlZCgyKSArICclJztcclxuICAgIHRoaXMubGVmdCA9IGxlZnQ7XHJcbiAgICB0aGlzLmRhdGEueCA9IE1hdGgucm91bmQobGVmdCAqIHRoaXMub3B0aW9ucy53aWR0aCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBPZmZzZXQgdG9wLlxyXG4gICAqL1xyXG4gIGlmICh0b3AgfHwgdG9wID09PSAwKSB7XHJcbiAgICBpZiAodG9wIDwgMCkgeyB0b3AgPSAwOyB9XHJcbiAgICBpZiAodG9wID4gdGhpcy5oZWlnaHQgLSAxKSB7IHRvcCA9IHRoaXMuaGVpZ2h0IC0gMTsgfVxyXG5cclxuICAgIHRoaXMuZWxlbWVudHMuY29udGFpbmVyLnN0eWxlLnRvcCA9ICgtdG9wICogMTAwKS50b0ZpeGVkKDIpICsgJyUnO1xyXG4gICAgdGhpcy50b3AgPSB0b3A7XHJcbiAgICB0aGlzLmRhdGEueSA9IE1hdGgucm91bmQodG9wICogdGhpcy5vcHRpb25zLmhlaWdodCk7XHJcbiAgfVxyXG59O1xyXG5cclxuQ3JvcHBlci5wcm90b3R5cGUuZml0SW1hZ2UgPSBmdW5jdGlvbigpIHtcclxuICB2YXIgcHJldldpZHRoLCByZWxhdGl2ZVJhdGlvO1xyXG5cclxuICBwcmV2V2lkdGggPSB0aGlzLndpZHRoO1xyXG4gIHJlbGF0aXZlUmF0aW8gPSB0aGlzLmhlaWdodCAvIHRoaXMud2lkdGg7XHJcblxyXG4gIGlmIChyZWxhdGl2ZVJhdGlvID4gMSkge1xyXG4gICAgdGhpcy53aWR0aCA9IDE7XHJcbiAgICB0aGlzLmhlaWdodCA9IHJlbGF0aXZlUmF0aW87XHJcbiAgfSBlbHNlIHtcclxuICAgIHRoaXMud2lkdGggPSAxIC8gcmVsYXRpdmVSYXRpbztcclxuICAgIHRoaXMuaGVpZ2h0ID0gMTtcclxuICB9XHJcblxyXG4gIHRoaXMuZWxlbWVudHMuY29udGFpbmVyLnN0eWxlLndpZHRoID0gKHRoaXMud2lkdGggKiAxMDApLnRvRml4ZWQoMikgKyAnJSc7XHJcbiAgdGhpcy5lbGVtZW50cy5jb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gKHRoaXMuaGVpZ2h0ICogMTAwKS50b0ZpeGVkKDIpICsgJyUnO1xyXG5cclxuICB0aGlzLmRhdGEuc2NhbGUgKj0gdGhpcy53aWR0aCAvIHByZXZXaWR0aDtcclxufTtcclxuXHJcbkNyb3BwZXIucHJvdG90eXBlLmNlbnRlckltYWdlID0gZnVuY3Rpb24oKSB7XHJcbiAgdGhpcy5zZXRPZmZzZXQoKHRoaXMud2lkdGggLSAxKSAvIDIsICh0aGlzLmhlaWdodCAtIDEpIC8gMik7XHJcbn07XHJcblxyXG4vKipcclxuICogRG8gYSByb3RhdGlvbiBvbiB0aGUgaW1hZ2Ugd2l0aCBkZWdyZWVzIGdpdmVuLlxyXG4gKiBAcGFyYW0gZGVncmVlc1xyXG4gKi9cclxuQ3JvcHBlci5wcm90b3R5cGUucm90YXRlSW1hZ2UgPSBmdW5jdGlvbihkZWdyZWVzKSB7XHJcbiAgLy8gT25seSByb3RhdGUgb2YgOTDCsC5cclxuICBpZiAoIShkZWdyZWVzICE9PSAwICYmIGRlZ3JlZXMgJSA5MCA9PT0gMCkpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignQ3JvcHBlcjogU3VwcG9ydCBvbmx5IG11bHRpcGxlIG9mIDkwwrAgZm9yIHJvdGF0aW9uLicpO1xyXG4gIH1cclxuXHJcbiAgLy8gU21hbGxlc3QgcG9zaXRpdmUgZXF1aXZhbGVudCBhbmdsZSAodG90YWwgcm90YXRpb24pLlxyXG4gIHRoaXMuYW5nbGUgPSAodGhpcy5hbmdsZSArIGRlZ3JlZXMpICUgMzYwO1xyXG4gIGlmICh0aGlzLmFuZ2xlIDwgMCkge1xyXG4gICAgdGhpcy5hbmdsZSArPSAzNjA7XHJcbiAgfVxyXG5cclxuICAvLyBEaW1lbnNpb25zIGFyZSBjaGFuZ2VkP1xyXG4gIGlmIChkZWdyZWVzICUgMTgwICE9PSAwKSB7XHJcbiAgICAvKipcclxuICAgICAqIFN3aXRjaCBjYW52YXMgZGltZW5zaW9ucyAoYXMgcGVyY2VudGFnZXMpLlxyXG4gICAgICogY2FudmFzV2lkdGggPSBAd2lkdGggKiB0aGlzLm9wdGlvbnMud2lkdGg7IGNhbnZhc0hlaWdodCA9IEBoZWlnaHQgKiB0aGlzLm9wdGlvbnMuaGVpZ2h0XHJcbiAgICAgKiBUbyBtYWtlIGNhbnZhc1dpZHRoID0gY2FudmFzSGVpZ2h0ICh0byBzd2l0Y2ggZGltZW5zaW9ucyk6XHJcbiAgICAgKiA9PiBuZXdXaWR0aCAqIHRoaXMub3B0aW9ucy53aWR0aCA9IEBoZWlnaHQgKiB0aGlzLm9wdGlvbnMuaGVpZ2h0XHJcbiAgICAgKiA9PiBuZXdXaWR0aCA9IEBoZWlnaHQgKiB0aGlzLm9wdGlvbnMuaGVpZ2h0IC8gdGhpcy5vcHRpb25zLndpZHRoXHJcbiAgICAgKiA9PiBuZXdXaWR0aCA9IEBoZWlnaHQgKiB0aGlzLmltYWdlUmF0aW9cclxuICAgICAqL1xyXG4gICAgdmFyIHRlbXBXID0gdGhpcy5oZWlnaHQgKiB0aGlzLmltYWdlUmF0aW87XHJcbiAgICB2YXIgdGVtcEggPSB0aGlzLndpZHRoIC8gdGhpcy5pbWFnZVJhdGlvO1xyXG4gICAgdGhpcy53aWR0aCA9IHRlbXBXO1xyXG4gICAgdGhpcy5oZWlnaHQgPSB0ZW1wSDtcclxuICAgIGlmICh0aGlzLndpZHRoID49IDEgJiYgdGhpcy5oZWlnaHQgPj0gMSkge1xyXG4gICAgICB0aGlzLmVsZW1lbnRzLmNvbnRhaW5lci5zdHlsZS53aWR0aCA9IHRoaXMud2lkdGggKiAxMDAgKyAnJSc7XHJcbiAgICAgIHRoaXMuZWxlbWVudHMuY29udGFpbmVyLnN0eWxlLmhlaWdodCA9IHRoaXMuaGVpZ2h0ICogMTAwICsgJyUnO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5maXRJbWFnZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdmFyIG5ld1dpZHRoID0gMTtcclxuICB2YXIgbmV3SGVpZ2h0ID0gMTtcclxuXHJcbiAgLy8gQWRqdXN0IGVsZW1lbnQncyAoaW1hZ2UpIGRpbWVuc2lvbnMgaW5zaWRlIHRoZSBjb250YWluZXIuXHJcbiAgaWYgKHRoaXMuYW5nbGUgJSAxODAgIT09IDApIHtcclxuICAgIHZhciByYXRpbyA9IHRoaXMuaGVpZ2h0IC8gdGhpcy53aWR0aCAqIHRoaXMuaW1hZ2VSYXRpbztcclxuICAgIG5ld1dpZHRoID0gcmF0aW87XHJcbiAgICBuZXdIZWlnaHQgPSAxIC8gcmF0aW87XHJcbiAgfVxyXG5cclxuICB0aGlzLmVsZW1lbnRzLmltYWdlLnN0eWxlLndpZHRoID0gbmV3V2lkdGggKiAxMDAgKyAnJSc7XHJcbiAgdGhpcy5lbGVtZW50cy5pbWFnZS5zdHlsZS5oZWlnaHQgPSBuZXdIZWlnaHQgKiAxMDAgKyAnJSc7XHJcbiAgdGhpcy5lbGVtZW50cy5pbWFnZS5zdHlsZS5sZWZ0ID0gKDEgLSBuZXdXaWR0aCkgLyAyICogMTAwICsgJyUnO1xyXG4gIHRoaXMuZWxlbWVudHMuaW1hZ2Uuc3R5bGUudG9wID0gKDEgLSBuZXdIZWlnaHQpIC8gMiAqIDEwMCArICclJztcclxuXHJcblxyXG4gIHRoaXMuZWxlbWVudHMuaW1hZ2Uuc3R5bGUudHJhbnNmb3JtID0gJ3JvdGF0ZSgnICsgdGhpcy5hbmdsZSArICdkZWcpJztcclxuICB0aGlzLmVsZW1lbnRzLmltYWdlLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICdyb3RhdGUoJyArIHRoaXMuYW5nbGUgKyAnZGVnKSc7XHJcbiAgdGhpcy5lbGVtZW50cy5pbWFnZS5zdHlsZS5tb3pUcmFuc2Zvcm0gPSAncm90YXRlKCcgKyB0aGlzLmFuZ2xlICsgJ2RlZyknO1xyXG4gIHRoaXMuZWxlbWVudHMuaW1hZ2Uuc3R5bGUubXNUcmFuc2Zvcm0gPSAncm90YXRlKCcgKyB0aGlzLmFuZ2xlICsgJ2RlZyknO1xyXG4gIHRoaXMuZWxlbWVudHMuaW1hZ2Uuc3R5bGUub1RyYW5zZm9ybSA9ICdyb3RhdGUoJyArIHRoaXMuYW5nbGUgKyAnZGVnKSc7XHJcblxyXG4gIHRoaXMuY2VudGVySW1hZ2UoKTtcclxuICB0aGlzLmRhdGEuZGVncmVlcyA9IHRoaXMuYW5nbGU7XHJcbn07XHJcblxyXG5Dcm9wcGVyLnByb3RvdHlwZS56b29tSW1hZ2UgPSBmdW5jdGlvbihmYWN0b3IpIHtcclxuICBpZiAoZmFjdG9yIDw9IDAgfHwgZmFjdG9yID09IDEpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIHZhciBvcmlnaW5hbFdpZHRoID0gdGhpcy53aWR0aDtcclxuXHJcbiAgaWYgKHRoaXMud2lkdGggKiBmYWN0b3IgPiAxICYmIHRoaXMuaGVpZ2h0ICogZmFjdG9yID4gMSkge1xyXG4gICAgdGhpcy5oZWlnaHQgKj0gZmFjdG9yO1xyXG4gICAgdGhpcy53aWR0aCAqPSBmYWN0b3I7XHJcbiAgICB0aGlzLmVsZW1lbnRzLmNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSAodGhpcy5oZWlnaHQgKiAxMDApLnRvRml4ZWQoMikgKyAnJSc7XHJcbiAgICB0aGlzLmVsZW1lbnRzLmNvbnRhaW5lci5zdHlsZS53aWR0aCA9ICh0aGlzLndpZHRoICogMTAwKS50b0ZpeGVkKDIpICsgJyUnO1xyXG4gICAgdGhpcy5kYXRhLnNjYWxlICo9IGZhY3RvcjtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy5maXRJbWFnZSgpO1xyXG4gICAgZmFjdG9yID0gdGhpcy53aWR0aCAvIG9yaWdpbmFsV2lkdGg7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBLZWVwIHdpbmRvdyBjZW50ZXIuXHJcbiAgICogVGhlIG9mZnNldHMgYXJlIHRoZSBkaXN0YW5jZXMgYmV0d2VlbiB0aGUgaW1hZ2UgcG9pbnQgaW4gdGhlIGNlbnRlciBvZiB0aGUgd3JhcHBlclxyXG4gICAqIGFuZCBlYWNoIGVkZ2Ugb2YgdGhlIGltYWdlLCBsZXNzIGhhbGYgdGhlIHNpemUgb2YgdGhlIHdpbmRvdy5cclxuICAgKiBQZXJjZW50YWdlIG9mZnNldHMgYXJlIHJlbGF0aXZlIHRvIHRoZSBjb250YWluZXIgKHRoZSB3cmFwcGVyKSwgc28gaGFsZiB0aGUgd3JhcHBlclxyXG4gICAqIGlzIDUwJSAoMC41KSBhbmQgd2hlbiB6b29taW5nIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIGFueSB0d28gcG9pbnRzIGluIHRoZSBpbWFnZVxyXG4gICAqIGdyb3dzIGJ5ICdmYWN0b3InLCBzbyB0aGUgbmV3IG9mZnNldHMgYXJlOlxyXG4gICAqXHJcbiAgICogb2Zmc2V0ID0gKHByZXYtY2VudGVyLXRvLWVkZ2UpICogZmFjdG9yIC0gaGFsZi13aW5kb3dcclxuICAgKlxyXG4gICAqL1xyXG4gIHZhciBsZWZ0ID0gKHRoaXMubGVmdCArIDAuNSkgKiBmYWN0b3IgLSAwLjU7XHJcbiAgdmFyIHRvcCA9ICh0aGlzLnRvcCArIDAuNSkgKiBmYWN0b3IgLSAwLjU7XHJcblxyXG4gIHRoaXMuc2V0T2Zmc2V0KGxlZnQsIHRvcCk7XHJcbn07XHJcblxyXG5Dcm9wcGVyLnByb3RvdHlwZS5jcm9wSW1hZ2UgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gdGhpcy5jcm9wSGFuZGxlcigpO1xyXG59O1xyXG5cclxuQ3JvcHBlci5wcm90b3R5cGUuY3JvcEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcclxuICB2YXIgY2FudmFzLCBjb250ZXh0O1xyXG5cclxuICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICBjYW52YXMuaGVpZ2h0ID0gdGhpcy5vcHRpb25zLmhlaWdodDtcclxuICBjYW52YXMud2lkdGggPSB0aGlzLm9wdGlvbnMud2lkdGg7XHJcblxyXG4gIHZhciBjeCA9IC1jYW52YXMud2lkdGggLyAyO1xyXG4gIHZhciBjeSA9IC1jYW52YXMuaGVpZ2h0IC8gMjtcclxuXHJcbiAgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gIGNvbnRleHQudHJhbnNsYXRlKC1jeCwtY3kpOyAvL21vdmUgdG8gY2VudHJlIG9mIGNhbnZhc1xyXG4gIGNvbnRleHQucm90YXRlKHRoaXMuZGF0YS5kZWdyZWVzICogTWF0aC5QSS8xODApO1xyXG4gIGNvbnRleHQuc2NhbGUodGhpcy5kYXRhLnNjYWxlLCB0aGlzLmRhdGEuc2NhbGUpO1xyXG5cclxuICBpZih0aGlzLmRhdGEuZGVncmVlcyA9PSAwKSB7IC8vIHNpbXBsZSBvZmZzZXRzIGZyb20gY2FudmFzIGNlbnRyZSAmIHNjYWxlXHJcbiAgICBjb250ZXh0LmRyYXdJbWFnZSh0aGlzLmVsZW1lbnRzLmltYWdlLFxyXG4gICAgICAoY3ggLSB0aGlzLmRhdGEueCkgLyB0aGlzLmRhdGEuc2NhbGUsXHJcbiAgICAgIChjeSAtIHRoaXMuZGF0YS55KSAvIHRoaXMuZGF0YS5zY2FsZVxyXG4gICAgKTtcclxuICB9IGVsc2UgaWYodGhpcy5kYXRhLmRlZ3JlZXMgPT0gOTApIHsgLy8gc3dhcCBheGlzIGFuZCByZXZlcnNlIHRoZSBuZXcgeSBvcmlnaW5cclxuICAgIGNvbnRleHQuZHJhd0ltYWdlKHRoaXMuZWxlbWVudHMuaW1hZ2UsXHJcbiAgICAgIChjeSAtIHRoaXMuZGF0YS55KSAvIHRoaXMuZGF0YS5zY2FsZSxcclxuICAgICAgKC0xICogdGhpcy5lbGVtZW50cy5pbWFnZS5uYXR1cmFsSGVpZ2h0KSArICgoLWN4ICsgdGhpcy5kYXRhLngpIC8gdGhpcy5kYXRhLnNjYWxlKVxyXG4gICAgKTtcclxuICB9IGVsc2UgaWYodGhpcy5kYXRhLmRlZ3JlZXMgPT0gMTgwKSB7IC8vIHJldmVyc2UgYm90aCBvcmlnaW5zXHJcbiAgICBjb250ZXh0LmRyYXdJbWFnZSh0aGlzLmVsZW1lbnRzLmltYWdlLFxyXG4gICAgICAoLTEgKiB0aGlzLmVsZW1lbnRzLmltYWdlLm5hdHVyYWxXaWR0aCkgKyAoKC1jeCArIHRoaXMuZGF0YS54KSAvIHRoaXMuZGF0YS5zY2FsZSksXHJcbiAgICAgICgtMSAqIHRoaXMuZWxlbWVudHMuaW1hZ2UubmF0dXJhbEhlaWdodCkgKyAoKC1jeSArIHRoaXMuZGF0YS55KSAvIHRoaXMuZGF0YS5zY2FsZSlcclxuICAgICk7XHJcbiAgfSBlbHNlIGlmKHRoaXMuZGF0YS5kZWdyZWVzID09IDI3MCkgeyAvLyBzd2FwIGF4aXMgYW5kIHJldmVyc2UgdGhlIG5ldyB4IG9yaWdpblxyXG4gICAgY29udGV4dC5kcmF3SW1hZ2UodGhpcy5lbGVtZW50cy5pbWFnZSxcclxuICAgICAgKC0xICogdGhpcy5lbGVtZW50cy5pbWFnZS5uYXR1cmFsV2lkdGgpICsgKCgtY3kgKyB0aGlzLmRhdGEueSkgLyB0aGlzLmRhdGEuc2NhbGUpLFxyXG4gICAgICAoY3ggLSB0aGlzLmRhdGEueCkgLyB0aGlzLmRhdGEuc2NhbGVcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICB2YXIgYmFzZTY0ID0gY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvanBlZycpO1xyXG4gIHRoaXMuZXZlbnRzLnRyaWdnZXJIYW5kbGVyKCdDcm9wcGVkJywgYmFzZTY0KTtcclxuICByZXR1cm4gYmFzZTY0O1xyXG59O1xyXG5cclxuQ3JvcHBlci5wcm90b3R5cGUudXNlSGFyZHdhcmVBY2NlbGVyYXRlID0gZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gIGVsZW1lbnQuc3R5bGUucGVyc3BlY3RpdmUgPSAnMTAwMHB4JztcclxuICBlbGVtZW50LnN0eWxlLmJhY2tmYWNlVmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xyXG59O1xyXG5cclxuQ3JvcHBlci5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24oZGVmYXVsdHMsIG9wdGlvbnMpIHtcclxuICB2YXIgdGFyZ2V0ID0gZGVmYXVsdHM7XHJcbiAgdmFyIGRlZmF1bHRzS2V5cyA9IE9iamVjdC5rZXlzKGRlZmF1bHRzKTtcclxuXHJcbiAgZGVmYXVsdHNLZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5LCBpbmRleCwga2V5c0FycmF5KSB7XHJcbiAgICBpZiAob3B0aW9uc1trZXldICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGFyZ2V0W2tleV0gPSBvcHRpb25zW2tleV07XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiB0YXJnZXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogSGVscGVyIGZvciBhZGRpbmcgbmV3IGV2ZW50IGxpc3RlbmVyIG9uIGVsZW1lbnQgZ2l2ZW4uXHJcbiAqIEBwYXJhbSBlbGVtZW50XHJcbiAqIEBwYXJhbSBldmVudE5hbWVzXHJcbiAqIEBwYXJhbSBmdW5jXHJcbiAqIEBwYXJhbSBjb250ZXh0XHJcbiAqL1xyXG5Dcm9wcGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uKGVsZW1lbnQsIGV2ZW50TmFtZXMsIGZ1bmMsIGNvbnRleHQpIHtcclxuICBldmVudE5hbWVzLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbihldmVudE5hbWUpIHtcclxuICAgIGlmIChjb250ZXh0KSB7XHJcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGZ1bmMuYmluZChjb250ZXh0KSwgZmFsc2UpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZnVuYywgZmFsc2UpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEhlbHBlciBmb3IgcmVtb3ZpbmcgZXZlbnQgbGlzdGVuZXIgaW4gZWxlbWVudCBnaXZlbi5cclxuICogQHBhcmFtIGVsZW1lbnRcclxuICogQHBhcmFtIGV2ZW50TmFtZXNcclxuICogQHBhcmFtIGZ1bmNcclxuICogQHBhcmFtIGNvbnRleHRcclxuICovXHJcbkNyb3BwZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24oZWxlbWVudCwgZXZlbnROYW1lcywgZnVuYywgY29udGV4dCkge1xyXG4gIGV2ZW50TmFtZXMuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50TmFtZSkge1xyXG4gICAgaWYgKGNvbnRleHQpIHtcclxuICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZnVuYy5iaW5kKGNvbnRleHQpLCBmYWxzZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBmdW5jLCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn07XHJcblxyXG4vKipcclxuICogSGVscGVyIGZvciBzZXR0aW5nIHBvaW50ZXIgcG9zaXRpb24uXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBldmVudFxyXG4gKiBAcmV0dXJucyB7e3g6ICosIHk6ICp9fVxyXG4gKi9cclxuQ3JvcHBlci5wcm90b3R5cGUuZ2V0UG9pbnRlclBvc2l0aW9uID0gZnVuY3Rpb24oZXZlbnQpIHtcclxuICBpZiAodGhpcy5pc1RvdWNoRXZlbnQoZXZlbnQpKSB7XHJcbiAgICBldmVudCA9IGV2ZW50LnRvdWNoZXNbMF07XHJcbiAgfVxyXG4gIHJldHVybiB7XHJcbiAgICB4OiBldmVudC5wYWdlWCxcclxuICAgIHk6IGV2ZW50LnBhZ2VZXHJcbiAgfTtcclxufTtcclxuLyoqXHJcbiAqIEhlbHBlciBmb3IgdGVzdGluZyBpZiB0aGUgZXZlbnQgaXMgdmFsaWQuXHJcbiAqIFRPRE86IENvbW1lbnQgdGhpcyBtYWdpYyB0aGluZy5cclxuICogQHBhcmFtIGV2ZW50XHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuQ3JvcHBlci5wcm90b3R5cGUuaXNWYWxpZEV2ZW50ID0gZnVuY3Rpb24oZXZlbnQpIHtcclxuICBpZiAodGhpcy5pc1RvdWNoRXZlbnQoZXZlbnQpKSB7XHJcbiAgICByZXR1cm4gZXZlbnQuY2hhbmdlZFRvdWNoZXMubGVuZ3RoID09PSAxO1xyXG4gIH1cclxuICByZXR1cm4gZXZlbnQud2hpY2ggPT09IDE7XHJcbn07XHJcblxyXG4vKipcclxuICogSGVscGVyIGZvciB0ZXN0aW5nIGlmIHRoZSBldmVudCBpcyB0b3VjaC5cclxuICogQHBhcmFtIGV2ZW50XHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuQ3JvcHBlci5wcm90b3R5cGUuaXNUb3VjaEV2ZW50ID0gZnVuY3Rpb24oZXZlbnQpIHtcclxuICByZXR1cm4gL3RvdWNoL2kudGVzdChldmVudC50eXBlKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBIZWxwZXIgZm9yIGFkZGluZyBhIHRpbWVzdGFtcCBhdCB0aGUgZW5kIG9mIGFuIFVSTC5cclxuICogQHBhcmFtIHVybFxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKi9cclxuQ3JvcHBlci5wcm90b3R5cGUuYWRkVGltZXN0YW1wID0gZnVuY3Rpb24odXJsKSB7XHJcbiAgdmFyIHRpbWVzdGFtcCA9ICd0aW1lc3RhbXA9JyArIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XHJcbiAgdmFyIHNpZ24gPSAnPyc7XHJcblxyXG4gIGlmICh1cmwuaW5kZXhPZignPycpICE9PSAtMSkge1xyXG4gICAgc2lnbiA9ICcmJztcclxuICB9XHJcblxyXG4gIHJldHVybiB1cmwuY29uY2F0KHNpZ24sIHRpbWVzdGFtcCk7XHJcbn07XHJcbi8qKlxyXG4gKiBIZWxwZXIgZm9yIGNoZWNraW5nIGlmIHRoZSBnaXZlbiB1cmwgaXMgY3Jvc3Mgb3JpZ2luLlxyXG4gKiBAcGFyYW0gdXJsXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuQ3JvcHBlci5wcm90b3R5cGUuaXNDcm9zc09yaWdpbiA9IGZ1bmN0aW9uKHVybCkge1xyXG4gIHZhciBwYXJ0cyA9IHVybC5tYXRjaCgpO1xyXG5cclxuICByZXR1cm4gQm9vbGVhbihwYXJ0cyAmJiAoXHJcbiAgICAgIHBhcnRzWzFdICE9PSBsb2NhdGlvbi5wcm90b2NvbCB8fFxyXG4gICAgICBwYXJ0c1syXSAhPT0gbG9jYXRpb24uaG9zdG5hbWUgfHxcclxuICAgICAgcGFydHNbM10gIT09IGxvY2F0aW9uLnBvcnRcclxuICAgICkpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEhlbHBlciBmb3IgY29udmVydGluZyBhcnJheUJ1ZmZlciB0byBiYXNlNjQuXHJcbiAqIEBwYXJhbSBhcnJheUJ1ZmZlclxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKi9cclxuQ3JvcHBlci5wcm90b3R5cGUuYmFzZTY0QXJyYXlCdWZmZXIgPSBmdW5jdGlvbihhcnJheUJ1ZmZlcikge1xyXG4gIHZhciBiYXNlNjQgPSAnJztcclxuICB2YXIgZW5jb2RpbmdzID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xyXG4gIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKTtcclxuICB2YXIgYnl0ZUxlbmd0aCA9IGJ5dGVzLmJ5dGVMZW5ndGg7XHJcbiAgdmFyIGJ5dGVSZW1haW5kZXIgPSBieXRlTGVuZ3RoICUgMztcclxuICB2YXIgbWFpbkxlbmd0aCA9IGJ5dGVMZW5ndGggLSBieXRlUmVtYWluZGVyO1xyXG4gIHZhciBhLCBiLCBjLCBkO1xyXG4gIHZhciBjaHVuaztcclxuICAvLyBNYWluIGxvb3AgZGVhbHMgd2l0aCBieXRlcyBpbiBjaHVua3Mgb2YgM1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWFpbkxlbmd0aDsgaSA9IGkgKyAzKSB7XHJcbiAgICAvLyBDb21iaW5lIHRoZSB0aHJlZSBieXRlcyBpbnRvIGEgc2luZ2xlIGludGVnZXJcclxuICAgIGNodW5rID0gKGJ5dGVzW2ldIDw8IDE2KSB8IChieXRlc1tpICsgMV0gPDwgOCkgfCBieXRlc1tpICsgMl07XHJcbiAgICAvLyBVc2UgYml0bWFza3MgdG8gZXh0cmFjdCA2LWJpdCBzZWdtZW50cyBmcm9tIHRoZSB0cmlwbGV0XHJcbiAgICBhID0gKGNodW5rICYgMTY1MTUwNzIpID4+IDE4OyAvLyAxNjUxNTA3MiA9ICgyXjYgLSAxKSA8PCAxOFxyXG4gICAgYiA9IChjaHVuayAmIDI1ODA0OCkgPj4gMTI7IC8vIDI1ODA0OCAgID0gKDJeNiAtIDEpIDw8IDEyXHJcbiAgICBjID0gKGNodW5rICYgNDAzMikgPj4gNjsgLy8gNDAzMiAgICAgPSAoMl42IC0gMSkgPDwgNlxyXG4gICAgZCA9IGNodW5rICYgNjM7ICAgICAgICAgICAgICAgLy8gNjMgICAgICAgPSAyXjYgLSAxXHJcbiAgICAvLyBDb252ZXJ0IHRoZSByYXcgYmluYXJ5IHNlZ21lbnRzIHRvIHRoZSBhcHByb3ByaWF0ZSBBU0NJSSBlbmNvZGluZ1xyXG4gICAgYmFzZTY0ICs9IGVuY29kaW5nc1thXSArIGVuY29kaW5nc1tiXSArIGVuY29kaW5nc1tjXSArIGVuY29kaW5nc1tkXTtcclxuICB9XHJcbiAgLy8gRGVhbCB3aXRoIHRoZSByZW1haW5pbmcgYnl0ZXMgYW5kIHBhZGRpbmdcclxuICBpZiAoYnl0ZVJlbWFpbmRlciA9PSAxKSB7XHJcbiAgICBjaHVuayA9IGJ5dGVzW21haW5MZW5ndGhdO1xyXG4gICAgYSA9IChjaHVuayAmIDI1MikgPj4gMjsgLy8gMjUyID0gKDJeNiAtIDEpIDw8IDJcclxuICAgIC8vIFNldCB0aGUgNCBsZWFzdCBzaWduaWZpY2FudCBiaXRzIHRvIHplcm9cclxuICAgIGIgPSAoY2h1bmsgJiAzKSA8PCA0OyAvLyAzICAgPSAyXjIgLSAxXHJcbiAgICBiYXNlNjQgKz0gZW5jb2RpbmdzW2FdICsgZW5jb2RpbmdzW2JdICsgJz09JztcclxuICB9IGVsc2UgaWYgKGJ5dGVSZW1haW5kZXIgPT0gMikge1xyXG4gICAgY2h1bmsgPSAoYnl0ZXNbbWFpbkxlbmd0aF0gPDwgOCkgfCBieXRlc1ttYWluTGVuZ3RoICsgMV07XHJcbiAgICBhID0gKGNodW5rICYgNjQ1MTIpID4+IDEwOyAvLyA2NDUxMiA9ICgyXjYgLSAxKSA8PCAxMFxyXG4gICAgYiA9IChjaHVuayAmIDEwMDgpID4+IDQ7IC8vIDEwMDggID0gKDJeNiAtIDEpIDw8IDRcclxuICAgIC8vIFNldCB0aGUgMiBsZWFzdCBzaWduaWZpY2FudCBiaXRzIHRvIHplcm9cclxuICAgIGMgPSAoY2h1bmsgJiAxNSkgPDwgMjsgLy8gMTUgICAgPSAyXjQgLSAxXHJcbiAgICBiYXNlNjQgKz0gZW5jb2RpbmdzW2FdICsgZW5jb2RpbmdzW2JdICsgZW5jb2RpbmdzW2NdICsgJz0nO1xyXG4gIH1cclxuICByZXR1cm4gYmFzZTY0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEhlbHBlciBmb3IgZXZlbnRzIGhhbmRsZXIuXHJcbiAqL1xyXG5Dcm9wcGVyLnByb3RvdHlwZS5ldmVudHMgPSBuZXcgZnVuY3Rpb24oKSB7XHJcbiAgdmFyIF90cmlnZ2VycyA9IHt9O1xyXG5cclxuICB0aGlzLm9uID0gZnVuY3Rpb24oZXZlbnQsIGNhbGxiYWNrKSB7XHJcbiAgICBpZiAoIV90cmlnZ2Vyc1tldmVudF0pIHtcclxuICAgICAgX3RyaWdnZXJzW2V2ZW50XSA9IFtdO1xyXG4gICAgfVxyXG4gICAgX3RyaWdnZXJzW2V2ZW50XS5wdXNoKGNhbGxiYWNrKTtcclxuICB9O1xyXG5cclxuICB0aGlzLnRyaWdnZXJIYW5kbGVyID0gZnVuY3Rpb24oZXZlbnQsIHBhcmFtcykge1xyXG4gICAgaWYgKF90cmlnZ2Vyc1tldmVudF0pIHtcclxuICAgICAgZm9yICh2YXIgaSBpbiBfdHJpZ2dlcnNbZXZlbnRdKSB7XHJcbiAgICAgICAgX3RyaWdnZXJzW2V2ZW50XVtpXShwYXJhbXMpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvaW1hZ2VDcm9wcGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2\n");

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

eval("if (false) {\r\n\trequire('./imageCropperDirective.test.js')(angular);\r\n}\r\n\r\nmodule.exports = function (angular, Cropper) {\r\n\t__webpack_require__(4);\r\n\tangular\r\n\t\t.module('imageCropper')\r\n\t\t.directive('imageCropper', function () {\r\n\t\t\tvar imageCropperController = function ($scope) {\r\n\t\t\t\tvar self = this;\r\n\t\t\t\tthis.$onInit = function () {\r\n\t\t\t\t\t// Get action labels.\r\n\t\t\t\t\tthis.actionLabels = this.actionLabels();\r\n\r\n\t\t\t\t\t// Get callback.\r\n\t\t\t\t\tthis.apiCallback = this.api();\r\n\t\t\t\t\tthis.cropCallback = this.cropCallback();\r\n\r\n\t\t\t\t\t// Eval for boolean values.\r\n\t\t\t\t\tthis.fitOnInit = eval(this.fitOnInit);\r\n\t\t\t\t\tthis.centerOnInit = eval(this.centerOnInit);\r\n\t\t\t\t\tthis.checkCrossOrigin = eval(this.checkCrossOrigin);\r\n\t\t\t\t\tthis.showControls = eval(this.showControls);\r\n\r\n\t\t\t\t}\r\n\t\t\t\tthis.init = function () {\r\n\t\t\t\t\tthis.target = this.element;\r\n\t\t\t\t\tthis.api = new Cropper(self);\r\n\r\n\t\t\t\t\t$scope.$watch('vm.imageUrl', function (newImageUrl, oldImageUrl) {\r\n\t\t\t\t\t\tif (angular.isDefined(newImageUrl) &&\r\n\t\t\t\t\t\t\t!angular.equals(newImageUrl, oldImageUrl)\r\n\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\tself.api.changeImage(newImageUrl);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\timageCropperController.$inject = ['$scope'];\r\n\r\n\t\t\treturn {\r\n\t\t\t\trestrict: 'E',\r\n\t\t\t\tscope: {\r\n\t\t\t\t\tcenterOnInit: '@',\r\n\t\t\t\t\tcheckCrossOrigin: '@',\r\n\t\t\t\t\tcropCallback: '&',\r\n\t\t\t\t\tapi: '&',\r\n\t\t\t\t\tfitOnInit: '@',\r\n\t\t\t\t\theight: '@',\r\n\t\t\t\t\timageUrl: '@',\r\n\t\t\t\t\tshowControls: '@',\r\n\t\t\t\t\twidth: '@',\r\n\t\t\t\t\tzoomStep: '@',\r\n\t\t\t\t\tactionLabels: '&'\r\n\t\t\t\t},\r\n\t\t\t\tbindToController: true,\r\n\t\t\t\tcontrollerAs: 'vm',\r\n\t\t\t\tcontroller: imageCropperController,\r\n\t\t\t\tlink: function (scope, element, attributes, controller) {\r\n\t\t\t\t\tcontroller.element = element[0];\r\n\t\t\t\t\tcontroller.init()\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t});\r\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW1hZ2VDcm9wcGVyRGlyZWN0aXZlLmpzP2VlZDUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsImZpbGUiOiIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaWYgKE9OX1RFU1QpIHtcclxuXHRyZXF1aXJlKCcuL2ltYWdlQ3JvcHBlckRpcmVjdGl2ZS50ZXN0LmpzJykoYW5ndWxhcik7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFuZ3VsYXIsIENyb3BwZXIpIHtcclxuXHRyZXF1aXJlKCcuL2FuZ3VsYXItaW1hZ2UtY3JvcHBlci5zY3NzJyk7XHJcblx0YW5ndWxhclxyXG5cdFx0Lm1vZHVsZSgnaW1hZ2VDcm9wcGVyJylcclxuXHRcdC5kaXJlY3RpdmUoJ2ltYWdlQ3JvcHBlcicsIGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dmFyIGltYWdlQ3JvcHBlckNvbnRyb2xsZXIgPSBmdW5jdGlvbiAoJHNjb3BlKSB7XHJcblx0XHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xyXG5cdFx0XHRcdHRoaXMuJG9uSW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHRcdC8vIEdldCBhY3Rpb24gbGFiZWxzLlxyXG5cdFx0XHRcdFx0dGhpcy5hY3Rpb25MYWJlbHMgPSB0aGlzLmFjdGlvbkxhYmVscygpO1xyXG5cclxuXHRcdFx0XHRcdC8vIEdldCBjYWxsYmFjay5cclxuXHRcdFx0XHRcdHRoaXMuYXBpQ2FsbGJhY2sgPSB0aGlzLmFwaSgpO1xyXG5cdFx0XHRcdFx0dGhpcy5jcm9wQ2FsbGJhY2sgPSB0aGlzLmNyb3BDYWxsYmFjaygpO1xyXG5cclxuXHRcdFx0XHRcdC8vIEV2YWwgZm9yIGJvb2xlYW4gdmFsdWVzLlxyXG5cdFx0XHRcdFx0dGhpcy5maXRPbkluaXQgPSBldmFsKHRoaXMuZml0T25Jbml0KTtcclxuXHRcdFx0XHRcdHRoaXMuY2VudGVyT25Jbml0ID0gZXZhbCh0aGlzLmNlbnRlck9uSW5pdCk7XHJcblx0XHRcdFx0XHR0aGlzLmNoZWNrQ3Jvc3NPcmlnaW4gPSBldmFsKHRoaXMuY2hlY2tDcm9zc09yaWdpbik7XHJcblx0XHRcdFx0XHR0aGlzLnNob3dDb250cm9scyA9IGV2YWwodGhpcy5zaG93Q29udHJvbHMpO1xyXG5cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhpcy5pbml0ID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdFx0dGhpcy50YXJnZXQgPSB0aGlzLmVsZW1lbnQ7XHJcblx0XHRcdFx0XHR0aGlzLmFwaSA9IG5ldyBDcm9wcGVyKHNlbGYpO1xyXG5cclxuXHRcdFx0XHRcdCRzY29wZS4kd2F0Y2goJ3ZtLmltYWdlVXJsJywgZnVuY3Rpb24gKG5ld0ltYWdlVXJsLCBvbGRJbWFnZVVybCkge1xyXG5cdFx0XHRcdFx0XHRpZiAoYW5ndWxhci5pc0RlZmluZWQobmV3SW1hZ2VVcmwpICYmXHJcblx0XHRcdFx0XHRcdFx0IWFuZ3VsYXIuZXF1YWxzKG5ld0ltYWdlVXJsLCBvbGRJbWFnZVVybClcclxuXHRcdFx0XHRcdFx0KSB7XHJcblx0XHRcdFx0XHRcdFx0c2VsZi5hcGkuY2hhbmdlSW1hZ2UobmV3SW1hZ2VVcmwpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRpbWFnZUNyb3BwZXJDb250cm9sbGVyLiRpbmplY3QgPSBbJyRzY29wZSddO1xyXG5cclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRyZXN0cmljdDogJ0UnLFxyXG5cdFx0XHRcdHNjb3BlOiB7XHJcblx0XHRcdFx0XHRjZW50ZXJPbkluaXQ6ICdAJyxcclxuXHRcdFx0XHRcdGNoZWNrQ3Jvc3NPcmlnaW46ICdAJyxcclxuXHRcdFx0XHRcdGNyb3BDYWxsYmFjazogJyYnLFxyXG5cdFx0XHRcdFx0YXBpOiAnJicsXHJcblx0XHRcdFx0XHRmaXRPbkluaXQ6ICdAJyxcclxuXHRcdFx0XHRcdGhlaWdodDogJ0AnLFxyXG5cdFx0XHRcdFx0aW1hZ2VVcmw6ICdAJyxcclxuXHRcdFx0XHRcdHNob3dDb250cm9sczogJ0AnLFxyXG5cdFx0XHRcdFx0d2lkdGg6ICdAJyxcclxuXHRcdFx0XHRcdHpvb21TdGVwOiAnQCcsXHJcblx0XHRcdFx0XHRhY3Rpb25MYWJlbHM6ICcmJ1xyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0YmluZFRvQ29udHJvbGxlcjogdHJ1ZSxcclxuXHRcdFx0XHRjb250cm9sbGVyQXM6ICd2bScsXHJcblx0XHRcdFx0Y29udHJvbGxlcjogaW1hZ2VDcm9wcGVyQ29udHJvbGxlcixcclxuXHRcdFx0XHRsaW5rOiBmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQsIGF0dHJpYnV0ZXMsIGNvbnRyb2xsZXIpIHtcclxuXHRcdFx0XHRcdGNvbnRyb2xsZXIuZWxlbWVudCA9IGVsZW1lbnRbMF07XHJcblx0XHRcdFx0XHRjb250cm9sbGVyLmluaXQoKVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fTtcclxuXHRcdH0pO1xyXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2ltYWdlQ3JvcHBlckRpcmVjdGl2ZS5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3\n");

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(5);\nif(typeof content === 'string') content = [[module.i, content, '']];\n// Prepare cssTransformation\nvar transform;\n\nvar options = {}\noptions.transform = transform\n// add the styles to the DOM\nvar update = __webpack_require__(7)(content, options);\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../node_modules/css-loader/index.js!../node_modules/sass-loader/lib/loader.js!./angular-image-cropper.scss\", function() {\n\t\t\tvar newContent = require(\"!!../node_modules/css-loader/index.js!../node_modules/sass-loader/lib/loader.js!./angular-image-cropper.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYW5ndWxhci1pbWFnZS1jcm9wcGVyLnNjc3M/OGRmMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSxFQUFFO0FBQzVDIiwiZmlsZSI6IjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9hbmd1bGFyLWltYWdlLWNyb3BwZXIuc2Nzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gUHJlcGFyZSBjc3NUcmFuc2Zvcm1hdGlvblxudmFyIHRyYW5zZm9ybTtcblxudmFyIG9wdGlvbnMgPSB7fVxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9hbmd1bGFyLWltYWdlLWNyb3BwZXIuc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9hbmd1bGFyLWltYWdlLWNyb3BwZXIuc2Nzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYW5ndWxhci1pbWFnZS1jcm9wcGVyLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4\n");

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(6)(undefined);\n// imports\n\n\n// module\nexports.push([module.i, \"body.imgCropper-dragging, body.imgCropper-dragging * {\\n  cursor: move !important;\\n  cursor: -webkit-grabbing !important;\\n  cursor: -moz-grabbing !important;\\n  cursor: grabbing !important;\\n  cursor: grabbing, move;\\n  /* IE hack */ }\\n\\n.imgCropper-wrapper {\\n  display: block;\\n  position: relative;\\n  overflow: hidden;\\n  cursor: move;\\n  cursor: -webkit-grab;\\n  cursor: -moz-grab;\\n  cursor: grab;\\n  cursor: grab, move;\\n  /* IE hack */ }\\n\\n.imgCropper-container {\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  text-align: center;\\n  margin: 0 !important;\\n  padding: 0 !important;\\n  border: none !important; }\\n\\n.imgCropper-container > * {\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  max-width: none;\\n  max-height: none;\\n  width: 100%;\\n  height: 100%;\\n  margin: 0 !important;\\n  padding: 0 !important;\\n  border: none !important; }\\n\\n.imgCropper-sample {\\n  position: absolute !important;\\n  top: -100000px     !important;\\n  left: -100000px    !important;\\n  width: auto        !important;\\n  height: auto       !important; }\\n\", \"\"]);\n\n// exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYW5ndWxhci1pbWFnZS1jcm9wcGVyLnNjc3M/NTZkZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOzs7QUFHQTtBQUNBLCtFQUFnRiw0QkFBNEIsd0NBQXdDLHFDQUFxQyxnQ0FBZ0MsMkJBQTJCLG1CQUFtQix5QkFBeUIsbUJBQW1CLHVCQUF1QixxQkFBcUIsaUJBQWlCLHlCQUF5QixzQkFBc0IsaUJBQWlCLHVCQUF1QixtQkFBbUIsMkJBQTJCLHVCQUF1QixXQUFXLFlBQVksdUJBQXVCLHlCQUF5QiwwQkFBMEIsNEJBQTRCLEVBQUUsK0JBQStCLHVCQUF1QixXQUFXLFlBQVksb0JBQW9CLHFCQUFxQixnQkFBZ0IsaUJBQWlCLHlCQUF5QiwwQkFBMEIsNEJBQTRCLEVBQUUsd0JBQXdCLGtDQUFrQyxrQ0FBa0Msa0NBQWtDLGtDQUFrQyxrQ0FBa0MsRUFBRTs7QUFFdmpDIiwiZmlsZSI6IjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHVuZGVmaW5lZCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJib2R5LmltZ0Nyb3BwZXItZHJhZ2dpbmcsIGJvZHkuaW1nQ3JvcHBlci1kcmFnZ2luZyAqIHtcXG4gIGN1cnNvcjogbW92ZSAhaW1wb3J0YW50O1xcbiAgY3Vyc29yOiAtd2Via2l0LWdyYWJiaW5nICFpbXBvcnRhbnQ7XFxuICBjdXJzb3I6IC1tb3otZ3JhYmJpbmcgIWltcG9ydGFudDtcXG4gIGN1cnNvcjogZ3JhYmJpbmcgIWltcG9ydGFudDtcXG4gIGN1cnNvcjogZ3JhYmJpbmcsIG1vdmU7XFxuICAvKiBJRSBoYWNrICovIH1cXG5cXG4uaW1nQ3JvcHBlci13cmFwcGVyIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIGN1cnNvcjogbW92ZTtcXG4gIGN1cnNvcjogLXdlYmtpdC1ncmFiO1xcbiAgY3Vyc29yOiAtbW96LWdyYWI7XFxuICBjdXJzb3I6IGdyYWI7XFxuICBjdXJzb3I6IGdyYWIsIG1vdmU7XFxuICAvKiBJRSBoYWNrICovIH1cXG5cXG4uaW1nQ3JvcHBlci1jb250YWluZXIge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAwO1xcbiAgbGVmdDogMDtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIG1hcmdpbjogMCAhaW1wb3J0YW50O1xcbiAgcGFkZGluZzogMCAhaW1wb3J0YW50O1xcbiAgYm9yZGVyOiBub25lICFpbXBvcnRhbnQ7IH1cXG5cXG4uaW1nQ3JvcHBlci1jb250YWluZXIgPiAqIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMDtcXG4gIGxlZnQ6IDA7XFxuICBtYXgtd2lkdGg6IG5vbmU7XFxuICBtYXgtaGVpZ2h0OiBub25lO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBtYXJnaW46IDAgIWltcG9ydGFudDtcXG4gIHBhZGRpbmc6IDAgIWltcG9ydGFudDtcXG4gIGJvcmRlcjogbm9uZSAhaW1wb3J0YW50OyB9XFxuXFxuLmltZ0Nyb3BwZXItc2FtcGxlIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZSAhaW1wb3J0YW50O1xcbiAgdG9wOiAtMTAwMDAwcHggICAgICFpbXBvcnRhbnQ7XFxuICBsZWZ0OiAtMTAwMDAwcHggICAgIWltcG9ydGFudDtcXG4gIHdpZHRoOiBhdXRvICAgICAgICAhaW1wb3J0YW50O1xcbiAgaGVpZ2h0OiBhdXRvICAgICAgICFpbXBvcnRhbnQ7IH1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyIS4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9zcmMvYW5ndWxhci1pbWFnZS1jcm9wcGVyLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5\n");

/***/ }),
/* 6 */
/***/ (function(module, exports) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanM/MTU5ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRCxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxjQUFjOztBQUVsRTtBQUNBIiwiZmlsZSI6IjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXNlU291cmNlTWFwKSB7XG5cdHZhciBsaXN0ID0gW107XG5cblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblx0XHRcdGlmKGl0ZW1bMl0pIHtcblx0XHRcdFx0cmV0dXJuIFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgY29udGVudCArIFwifVwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdFx0XHR9XG5cdFx0fSkuam9pbihcIlwiKTtcblx0fTtcblxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcblx0dmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnO1xuXHR2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cdGlmICghY3NzTWFwcGluZykge1xuXHRcdHJldHVybiBjb250ZW50O1xuXHR9XG5cblx0aWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuXHRcdHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcblx0fVxuXG5cdHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cdHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuXHR2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xuXG5cdHJldHVybiAnLyojICcgKyBkYXRhICsgJyAqLyc7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6\n");

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(selector) {\n\t\tif (typeof memo[selector] === \"undefined\") {\n\t\t\tmemo[selector] = fn.call(this, selector);\n\t\t}\n\n\t\treturn memo[selector]\n\t};\n})(function (target) {\n\treturn document.querySelector(target)\n});\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(8);\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton) options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n\tif (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else {\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\toptions.attrs.type = \"text/css\";\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\toptions.attrs.type = \"text/css\";\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = options.transform(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanM/MzEzMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixzQkFBc0I7QUFDdkM7O0FBRUE7QUFDQSxtQkFBbUIsMkJBQTJCOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLDJCQUEyQjtBQUM1QztBQUNBOztBQUVBLFFBQVEsdUJBQXVCO0FBQy9CO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsaUJBQWlCLHVCQUF1QjtBQUN4QztBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQsa0RBQWtELHNCQUFzQjtBQUN4RTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7O0FBRUEsNkJBQTZCLG1CQUFtQjs7QUFFaEQ7O0FBRUE7O0FBRUE7QUFDQSIsImZpbGUiOiI3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cblxudmFyIHN0eWxlc0luRG9tID0ge307XG5cbnZhclx0bWVtb2l6ZSA9IGZ1bmN0aW9uIChmbikge1xuXHR2YXIgbWVtbztcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG1lbW87XG5cdH07XG59O1xuXG52YXIgaXNPbGRJRSA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xuXHQvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuXHQvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG5cdC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXJcblx0Ly8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXG5cdC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuXHRyZXR1cm4gd2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2I7XG59KTtcblxudmFyIGdldEVsZW1lbnQgPSAoZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vID0ge307XG5cblx0cmV0dXJuIGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG5cdFx0aWYgKHR5cGVvZiBtZW1vW3NlbGVjdG9yXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0bWVtb1tzZWxlY3Rvcl0gPSBmbi5jYWxsKHRoaXMsIHNlbGVjdG9yKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWVtb1tzZWxlY3Rvcl1cblx0fTtcbn0pKGZ1bmN0aW9uICh0YXJnZXQpIHtcblx0cmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KVxufSk7XG5cbnZhciBzaW5nbGV0b24gPSBudWxsO1xudmFyXHRzaW5nbGV0b25Db3VudGVyID0gMDtcbnZhclx0c3R5bGVzSW5zZXJ0ZWRBdFRvcCA9IFtdO1xuXG52YXJcdGZpeFVybHMgPSByZXF1aXJlKFwiLi91cmxzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcblx0aWYgKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xuXHRcdGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcblx0fVxuXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdG9wdGlvbnMuYXR0cnMgPSB0eXBlb2Ygb3B0aW9ucy5hdHRycyA9PT0gXCJvYmplY3RcIiA/IG9wdGlvbnMuYXR0cnMgOiB7fTtcblxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXHRpZiAoIW9wdGlvbnMuc2luZ2xldG9uKSBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSA8aGVhZD4gZWxlbWVudFxuXHRpZiAoIW9wdGlvbnMuaW5zZXJ0SW50bykgb3B0aW9ucy5pbnNlcnRJbnRvID0gXCJoZWFkXCI7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgYm90dG9tIG9mIHRoZSB0YXJnZXRcblx0aWYgKCFvcHRpb25zLmluc2VydEF0KSBvcHRpb25zLmluc2VydEF0ID0gXCJib3R0b21cIjtcblxuXHR2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKGxpc3QsIG9wdGlvbnMpO1xuXG5cdGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSAobmV3TGlzdCkge1xuXHRcdHZhciBtYXlSZW1vdmUgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XG5cdFx0XHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XG5cdFx0fVxuXG5cdFx0aWYobmV3TGlzdCkge1xuXHRcdFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0LCBvcHRpb25zKTtcblx0XHRcdGFkZFN0eWxlc1RvRG9tKG5ld1N0eWxlcywgb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXTtcblxuXHRcdFx0aWYoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSBkb21TdHlsZS5wYXJ0c1tqXSgpO1xuXG5cdFx0XHRcdGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufTtcblxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20gKHN0eWxlcywgb3B0aW9ucykge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG5cdFx0aWYoZG9tU3R5bGUpIHtcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHBhcnRzID0gW107XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXG5cdFx0XHRzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHtpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzfTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gbGlzdFRvU3R5bGVzIChsaXN0LCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZXMgPSBbXTtcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcblx0XHR2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcblx0XHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xuXHRcdHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcblxuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKSBzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge2lkOiBpZCwgcGFydHM6IFtwYXJ0XX0pO1xuXHRcdGVsc2UgbmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xuXHR9XG5cblx0cmV0dXJuIHN0eWxlcztcbn1cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50IChvcHRpb25zLCBzdHlsZSkge1xuXHR2YXIgdGFyZ2V0ID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEludG8pXG5cblx0aWYgKCF0YXJnZXQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydEludG8nIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcblx0fVxuXG5cdHZhciBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCA9IHN0eWxlc0luc2VydGVkQXRUb3Bbc3R5bGVzSW5zZXJ0ZWRBdFRvcC5sZW5ndGggLSAxXTtcblxuXHRpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ0b3BcIikge1xuXHRcdGlmICghbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3ApIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIHRhcmdldC5maXJzdENoaWxkKTtcblx0XHR9IGVsc2UgaWYgKGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdFx0fVxuXHRcdHN0eWxlc0luc2VydGVkQXRUb3AucHVzaChzdHlsZSk7XG5cdH0gZWxzZSBpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJib3R0b21cIikge1xuXHRcdHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcuIE11c3QgYmUgJ3RvcCcgb3IgJ2JvdHRvbScuXCIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudCAoc3R5bGUpIHtcblx0aWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblx0c3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG5cblx0dmFyIGlkeCA9IHN0eWxlc0luc2VydGVkQXRUb3AuaW5kZXhPZihzdHlsZSk7XG5cdGlmKGlkeCA+PSAwKSB7XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcblx0fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXG5cdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblxuXHRhZGRBdHRycyhzdHlsZSwgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZSk7XG5cblx0cmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMaW5rRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuXG5cdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0b3B0aW9ucy5hdHRycy5yZWwgPSBcInN0eWxlc2hlZXRcIjtcblxuXHRhZGRBdHRycyhsaW5rLCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIGxpbmspO1xuXG5cdHJldHVybiBsaW5rO1xufVxuXG5mdW5jdGlvbiBhZGRBdHRycyAoZWwsIGF0dHJzKSB7XG5cdE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRlbC5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyc1trZXldKTtcblx0fSk7XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlIChvYmosIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlLCB1cGRhdGUsIHJlbW92ZSwgcmVzdWx0O1xuXG5cdC8vIElmIGEgdHJhbnNmb3JtIGZ1bmN0aW9uIHdhcyBkZWZpbmVkLCBydW4gaXQgb24gdGhlIGNzc1xuXHRpZiAob3B0aW9ucy50cmFuc2Zvcm0gJiYgb2JqLmNzcykge1xuXHQgICAgcmVzdWx0ID0gb3B0aW9ucy50cmFuc2Zvcm0ob2JqLmNzcyk7XG5cblx0ICAgIGlmIChyZXN1bHQpIHtcblx0ICAgIFx0Ly8gSWYgdHJhbnNmb3JtIHJldHVybnMgYSB2YWx1ZSwgdXNlIHRoYXQgaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgY3NzLlxuXHQgICAgXHQvLyBUaGlzIGFsbG93cyBydW5uaW5nIHJ1bnRpbWUgdHJhbnNmb3JtYXRpb25zIG9uIHRoZSBjc3MuXG5cdCAgICBcdG9iai5jc3MgPSByZXN1bHQ7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgXHQvLyBJZiB0aGUgdHJhbnNmb3JtIGZ1bmN0aW9uIHJldHVybnMgYSBmYWxzeSB2YWx1ZSwgZG9uJ3QgYWRkIHRoaXMgY3NzLlxuXHQgICAgXHQvLyBUaGlzIGFsbG93cyBjb25kaXRpb25hbCBsb2FkaW5nIG9mIGNzc1xuXHQgICAgXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCAgICBcdFx0Ly8gbm9vcFxuXHQgICAgXHR9O1xuXHQgICAgfVxuXHR9XG5cblx0aWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG5cdFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG5cblx0XHRzdHlsZSA9IHNpbmdsZXRvbiB8fCAoc2luZ2xldG9uID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcblxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgZmFsc2UpO1xuXHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgdHJ1ZSk7XG5cblx0fSBlbHNlIGlmIChcblx0XHRvYmouc291cmNlTWFwICYmXG5cdFx0dHlwZW9mIFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5jcmVhdGVPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwucmV2b2tlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgQmxvYiA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIlxuXHQpIHtcblx0XHRzdHlsZSA9IGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IHVwZGF0ZUxpbmsuYmluZChudWxsLCBzdHlsZSwgb3B0aW9ucyk7XG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcblxuXHRcdFx0aWYoc3R5bGUuaHJlZikgVVJMLnJldm9rZU9iamVjdFVSTChzdHlsZS5ocmVmKTtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdHN0eWxlID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZSk7XG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcblx0XHR9O1xuXHR9XG5cblx0dXBkYXRlKG9iaik7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChuZXdPYmopIHtcblx0XHRpZiAobmV3T2JqKSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdG5ld09iai5jc3MgPT09IG9iai5jc3MgJiZcblx0XHRcdFx0bmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiZcblx0XHRcdFx0bmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcFxuXHRcdFx0KSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dXBkYXRlKG9iaiA9IG5ld09iaik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlbW92ZSgpO1xuXHRcdH1cblx0fTtcbn1cblxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcblx0dmFyIHRleHRTdG9yZSA9IFtdO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG5cdFx0dGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuXG5cdFx0cmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG5cdH07XG59KSgpO1xuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnIChzdHlsZSwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG5cdHZhciBjc3MgPSByZW1vdmUgPyBcIlwiIDogb2JqLmNzcztcblxuXHRpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuXHRcdHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuXHR9IGVsc2Uge1xuXHRcdHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcblx0XHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XG5cblx0XHRpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcblxuXHRcdGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuXHRcdFx0c3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3R5bGUuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcgKHN0eWxlLCBvYmopIHtcblx0dmFyIGNzcyA9IG9iai5jc3M7XG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcblxuXHRpZihtZWRpYSkge1xuXHRcdHN0eWxlLnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIG1lZGlhKVxuXHR9XG5cblx0aWYoc3R5bGUuc3R5bGVTaGVldCkge1xuXHRcdHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcblx0fSBlbHNlIHtcblx0XHR3aGlsZShzdHlsZS5maXJzdENoaWxkKSB7XG5cdFx0XHRzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcblx0XHR9XG5cblx0XHRzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcblx0fVxufVxuXG5mdW5jdGlvbiB1cGRhdGVMaW5rIChsaW5rLCBvcHRpb25zLCBvYmopIHtcblx0dmFyIGNzcyA9IG9iai5jc3M7XG5cdHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuXG5cdC8qXG5cdFx0SWYgY29udmVydFRvQWJzb2x1dGVVcmxzIGlzbid0IGRlZmluZWQsIGJ1dCBzb3VyY2VtYXBzIGFyZSBlbmFibGVkXG5cdFx0YW5kIHRoZXJlIGlzIG5vIHB1YmxpY1BhdGggZGVmaW5lZCB0aGVuIGxldHMgdHVybiBjb252ZXJ0VG9BYnNvbHV0ZVVybHNcblx0XHRvbiBieSBkZWZhdWx0LiAgT3RoZXJ3aXNlIGRlZmF1bHQgdG8gdGhlIGNvbnZlcnRUb0Fic29sdXRlVXJscyBvcHRpb25cblx0XHRkaXJlY3RseVxuXHQqL1xuXHR2YXIgYXV0b0ZpeFVybHMgPSBvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyA9PT0gdW5kZWZpbmVkICYmIHNvdXJjZU1hcDtcblxuXHRpZiAob3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgfHwgYXV0b0ZpeFVybHMpIHtcblx0XHRjc3MgPSBmaXhVcmxzKGNzcyk7XG5cdH1cblxuXHRpZiAoc291cmNlTWFwKSB7XG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcblx0XHRjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArIFwiICovXCI7XG5cdH1cblxuXHR2YXIgYmxvYiA9IG5ldyBCbG9iKFtjc3NdLCB7IHR5cGU6IFwidGV4dC9jc3NcIiB9KTtcblxuXHR2YXIgb2xkU3JjID0gbGluay5ocmVmO1xuXG5cdGxpbmsuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG5cblx0aWYob2xkU3JjKSBVUkwucmV2b2tlT2JqZWN0VVJMKG9sZFNyYyk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7\n");

/***/ }),
/* 8 */
/***/ (function(module, exports) {

eval("\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzPzk4OTMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxXQUFXLEVBQUU7QUFDckQsd0NBQXdDLFdBQVcsRUFBRTs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxzQ0FBc0M7QUFDdEMsR0FBRztBQUNIO0FBQ0EsOERBQThEO0FBQzlEOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSIsImZpbGUiOiI4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIFdoZW4gc291cmNlIG1hcHMgYXJlIGVuYWJsZWQsIGBzdHlsZS1sb2FkZXJgIHVzZXMgYSBsaW5rIGVsZW1lbnQgd2l0aCBhIGRhdGEtdXJpIHRvXG4gKiBlbWJlZCB0aGUgY3NzIG9uIHRoZSBwYWdlLiBUaGlzIGJyZWFrcyBhbGwgcmVsYXRpdmUgdXJscyBiZWNhdXNlIG5vdyB0aGV5IGFyZSByZWxhdGl2ZSB0byBhXG4gKiBidW5kbGUgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBwYWdlLlxuICpcbiAqIE9uZSBzb2x1dGlvbiBpcyB0byBvbmx5IHVzZSBmdWxsIHVybHMsIGJ1dCB0aGF0IG1heSBiZSBpbXBvc3NpYmxlLlxuICpcbiAqIEluc3RlYWQsIHRoaXMgZnVuY3Rpb24gXCJmaXhlc1wiIHRoZSByZWxhdGl2ZSB1cmxzIHRvIGJlIGFic29sdXRlIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBwYWdlIGxvY2F0aW9uLlxuICpcbiAqIEEgcnVkaW1lbnRhcnkgdGVzdCBzdWl0ZSBpcyBsb2NhdGVkIGF0IGB0ZXN0L2ZpeFVybHMuanNgIGFuZCBjYW4gYmUgcnVuIHZpYSB0aGUgYG5wbSB0ZXN0YCBjb21tYW5kLlxuICpcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3MpIHtcbiAgLy8gZ2V0IGN1cnJlbnQgbG9jYXRpb25cbiAgdmFyIGxvY2F0aW9uID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubG9jYXRpb247XG5cbiAgaWYgKCFsb2NhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImZpeFVybHMgcmVxdWlyZXMgd2luZG93LmxvY2F0aW9uXCIpO1xuICB9XG5cblx0Ly8gYmxhbmsgb3IgbnVsbD9cblx0aWYgKCFjc3MgfHwgdHlwZW9mIGNzcyAhPT0gXCJzdHJpbmdcIikge1xuXHQgIHJldHVybiBjc3M7XG4gIH1cblxuICB2YXIgYmFzZVVybCA9IGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgbG9jYXRpb24uaG9zdDtcbiAgdmFyIGN1cnJlbnREaXIgPSBiYXNlVXJsICsgbG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvXFwvW15cXC9dKiQvLCBcIi9cIik7XG5cblx0Ly8gY29udmVydCBlYWNoIHVybCguLi4pXG5cdC8qXG5cdFRoaXMgcmVndWxhciBleHByZXNzaW9uIGlzIGp1c3QgYSB3YXkgdG8gcmVjdXJzaXZlbHkgbWF0Y2ggYnJhY2tldHMgd2l0aGluXG5cdGEgc3RyaW5nLlxuXG5cdCAvdXJsXFxzKlxcKCAgPSBNYXRjaCBvbiB0aGUgd29yZCBcInVybFwiIHdpdGggYW55IHdoaXRlc3BhY2UgYWZ0ZXIgaXQgYW5kIHRoZW4gYSBwYXJlbnNcblx0ICAgKCAgPSBTdGFydCBhIGNhcHR1cmluZyBncm91cFxuXHQgICAgICg/OiAgPSBTdGFydCBhIG5vbi1jYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAgICAgW14pKF0gID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICg/OiAgPSBTdGFydCBhbm90aGVyIG5vbi1jYXB0dXJpbmcgZ3JvdXBzXG5cdCAgICAgICAgICAgICAgICAgW14pKF0rICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgICAgICBbXikoXSogID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgXFwpICA9IE1hdGNoIGEgZW5kIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICApICA9IEVuZCBHcm91cFxuICAgICAgICAgICAgICAqXFwpID0gTWF0Y2ggYW55dGhpbmcgYW5kIHRoZW4gYSBjbG9zZSBwYXJlbnNcbiAgICAgICAgICApICA9IENsb3NlIG5vbi1jYXB0dXJpbmcgZ3JvdXBcbiAgICAgICAgICAqICA9IE1hdGNoIGFueXRoaW5nXG4gICAgICAgKSAgPSBDbG9zZSBjYXB0dXJpbmcgZ3JvdXBcblx0IFxcKSAgPSBNYXRjaCBhIGNsb3NlIHBhcmVuc1xuXG5cdCAvZ2kgID0gR2V0IGFsbCBtYXRjaGVzLCBub3QgdGhlIGZpcnN0LiAgQmUgY2FzZSBpbnNlbnNpdGl2ZS5cblx0ICovXG5cdHZhciBmaXhlZENzcyA9IGNzcy5yZXBsYWNlKC91cmxcXHMqXFwoKCg/OlteKShdfFxcKCg/OlteKShdK3xcXChbXikoXSpcXCkpKlxcKSkqKVxcKS9naSwgZnVuY3Rpb24oZnVsbE1hdGNoLCBvcmlnVXJsKSB7XG5cdFx0Ly8gc3RyaXAgcXVvdGVzIChpZiB0aGV5IGV4aXN0KVxuXHRcdHZhciB1bnF1b3RlZE9yaWdVcmwgPSBvcmlnVXJsXG5cdFx0XHQudHJpbSgpXG5cdFx0XHQucmVwbGFjZSgvXlwiKC4qKVwiJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KVxuXHRcdFx0LnJlcGxhY2UoL14nKC4qKSckLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pO1xuXG5cdFx0Ly8gYWxyZWFkeSBhIGZ1bGwgdXJsPyBubyBjaGFuZ2Vcblx0XHRpZiAoL14oI3xkYXRhOnxodHRwOlxcL1xcL3xodHRwczpcXC9cXC98ZmlsZTpcXC9cXC9cXC8pL2kudGVzdCh1bnF1b3RlZE9yaWdVcmwpKSB7XG5cdFx0ICByZXR1cm4gZnVsbE1hdGNoO1xuXHRcdH1cblxuXHRcdC8vIGNvbnZlcnQgdGhlIHVybCB0byBhIGZ1bGwgdXJsXG5cdFx0dmFyIG5ld1VybDtcblxuXHRcdGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi8vXCIpID09PSAwKSB7XG5cdFx0ICBcdC8vVE9ETzogc2hvdWxkIHdlIGFkZCBwcm90b2NvbD9cblx0XHRcdG5ld1VybCA9IHVucXVvdGVkT3JpZ1VybDtcblx0XHR9IGVsc2UgaWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiL1wiKSA9PT0gMCkge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJhc2UgdXJsXG5cdFx0XHRuZXdVcmwgPSBiYXNlVXJsICsgdW5xdW90ZWRPcmlnVXJsOyAvLyBhbHJlYWR5IHN0YXJ0cyB3aXRoICcvJ1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byBjdXJyZW50IGRpcmVjdG9yeVxuXHRcdFx0bmV3VXJsID0gY3VycmVudERpciArIHVucXVvdGVkT3JpZ1VybC5yZXBsYWNlKC9eXFwuXFwvLywgXCJcIik7IC8vIFN0cmlwIGxlYWRpbmcgJy4vJ1xuXHRcdH1cblxuXHRcdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgdXJsKC4uLilcblx0XHRyZXR1cm4gXCJ1cmwoXCIgKyBKU09OLnN0cmluZ2lmeShuZXdVcmwpICsgXCIpXCI7XG5cdH0pO1xuXG5cdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgY3NzXG5cdHJldHVybiBmaXhlZENzcztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL3VybHMuanNcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8\n");

/***/ })
/******/ ]);
});